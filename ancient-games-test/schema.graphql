directive @hasRoles(roles: [UserRole!]!) on FIELD_DEFINITION

"""Controls the rate of traffic."""
directive @rateLimit(
  """Number of occurrences allowed over duration."""
  limit: Int! = 60

  """Number of seconds before limit is reset."""
  duration: Int! = 60
) on OBJECT | FIELD_DEFINITION

directive @cacheControl(maxAge: Int, scope: CacheControlScope) on OBJECT | FIELD_DEFINITION

type AchievementReward {
  amount: Float!
  ancestorBoxId: ID
  box: Box
  currency: String
  itemVariantId: ID
  itemVariant: ItemVariant
  onlyForMarketId: ID
  onlyForMarket: Market
  type: AchievementRewardType!
  walletType: WalletType
}

input AchievementRewardInput {
  amount: Float!
  ancestorBoxId: ID
  currency: String
  itemVariantId: ID
  onlyForMarketId: ID
  type: AchievementRewardType!
  walletType: WalletType
}

enum AchievementRewardType {
  BOX
  ITEM_VARIANT
  JACKPOT_TICKET
  WALLET
  XP
}

type AchievementTrigger {
  ancestorBoxId: ID
  channels: [String]
  contains: String
  currency: String
  gameTypes: [GameType!]
  minAmount: Float
  minPayoutValue: Float
  minUserProfit: Float
  payoutItemVariantIds: [ID!]
  payoutItemVariants: [ItemVariant!]
  type: AchievementTriggerType!
  rouletteBetMode: BetMode
  rouletteSelections: [Int]
  userItemUsed: Boolean
}

input AchievementTriggerInput {
  ancestorBoxId: ID
  channels: [String]
  contains: String
  currency: String
  gameTypes: [GameType!]
  minAmount: Float
  minPayoutValue: Float
  minUserProfit: Float
  payoutItemVariantIds: [ID!]
  rouletteBet: [Int]
  rouletteBetMode: BetMode
  rouletteSelections: [Int]
  type: AchievementTriggerType!
  userItemUsed: Boolean
}

enum AchievementTriggerType {
  CHAT_MESSAGE
  LOST_WAGER_ON_GAME
  TWITTER_FOLLOWER
  WAGER_ON_GAME
  WON_WAGER_ON_GAME
}

type BonusAmount {
  amount: Float
  currency: String
  market: Market
  marketId: ID
}

type Achievement implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  name: String!
  description: String!
  imageUrl: String!
  bonusAmounts: [BonusAmount!] @deprecated(reason: "Use rewards instead")
  rewards: [AchievementReward!]!
  xpAmount: Int @deprecated(reason: "Use rewards instead")
  bonusExpirySeconds: Int @deprecated(reason: "Use rewardsExpireAfterSeconds instead")
  rewardsExpireAfterSeconds: Int!
  enabled: Boolean!
  users: [User]
  type: AchievementType
  autoClaim: Boolean!
  limitPerUser: Int
  trigger: AchievementTrigger
  userAchievements(after: String, first: PaginationAmount, before: String, last: PaginationAmount, userId: ID): UserAchievementConnection!
}

type AchievementConnection {
  pageInfo: PageInfo!
  edges: [AchievementEdge]
  total: Int
}

type AchievementEdge {
  node: Achievement
  cursor: String!
}

type CreateAchievementPayload {
  achievement: Achievement
}

type UpdateAchievementPayload {
  achievement: Achievement
}

type DeleteAchievementPayload {
  achievement: Achievement
}

type FlushAchievementCachePayload {
  achievements: [Achievement]
}

type Query {
  achievement(id: ID!): Achievement
  achievements(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [AchievementOrderBy], achievementIds: [ID!], enabled: Boolean, name: String, types: [AchievementType!]): AchievementConnection!
  getAffiliateImageUrls(input: AffiliateUserIdentifier): AffiliateUrlsPayload
  getAffiliateImageUrl(input: AffiliatePromoImageIdentifier): AffiliateUrlPayload
  getAffiliateBlogPosts(input: AffiliateBlogInput): AffiliateBlogPostsPayload
  affiliateLoanRequest(id: ID!): AffiliateLoanRequest
  affiliateLoanRequests(input: AffiliateLoanRequestArgs): AffiliateLoanRequestConnection!
  affiliateActiveCountInDateRange(input: AffiliateActiveCountInput): AffiliateActiveCountResult
  affiliateAllTime(input: AffiliateAllTimeInput): AffiliateAllTimeResult
  affiliateDailyEarnings(input: AffiliateEarningsInput): [AffiliateEarningsResult]
  affiliateMonthlyEarnings(input: AffiliateEarningsInput): [AffiliateEarningsResult]
  affiliateStatusCounts(input: AffiliateStatusCountsInput): AffiliateStatusCountResult
  affiliateTotalEarnings(input: AffiliateEarningsInput): [AffiliateEarningsResult]
  refereeActivity(input: RefereeActivityInput!): RefereeActivityResult
  refereeDailyOrHourlyActivity(input: RefereeDailyActivityInput): RefereeDailyActivityResult
  totalCommisionGivenAway: TotalCommisionGivenAwayPayload!
  getRefereeStatus(input: RefereeStatusInput): RefereeStatusResult!
  getAffiliateRanJobsByDay(jobType: AffiliateReportJobType, limit: Int): [AffiliateRanJobsByDay!]
  affiliateSearch(input: AffiliateSearchInputs): AffiliateSearchConnection!
  affiliateTier(id: ID!): AffiliateTier
  affiliateTiers(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [AffiliateTierOrderBy], ancestorAffiliateTierId: ID): AffiliateTierConnection!
  asset(id: ID): Asset
  assets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [AssetOrderBy], fileName: String): AssetConnection!
  auditLog(id: ID!): AuditLog
  auditLogs(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [AuditLogOrderBy], actions: [AuditLogAction!], externalId: Int, externalModel: String, userIds: [ID!]): AuditLogConnection!
  bet(id: ID!): Bet
  bets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [BetOrderBy], gameId: ID, userId: ID, selection: Int, selections: [Int!], minDate: SequelizeDate, maxDate: SequelizeDate): BetConnection!
  cachedGameBets(gameId: ID!): [Bet!]!
  boxOpening(id: ID): BoxOpening
  boxOpenings(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [BoxOpeningOrderBy], boxId: ID, userId: ID, ancestorBoxId: ID, minItemValue: Float, maxItemValue: Float, minDate: SequelizeDate, maxDate: SequelizeDate, name: String, hasPvpGame: Boolean, pvpGameId: ID, boxSlotTypes: [BoxSlotType!]): BoxOpeningConnection!
  boxOpeningsByValue(limit: PaginationAmount, ancestorBoxId: ID, boxSlug: String): [BoxOpening] @deprecated(reason: "use drop cache resolver instead")
  boxOpeningsByTime(limit: PaginationAmount, ancestorBoxId: ID, boxSlug: String): [BoxOpening] @deprecated(reason: "use drop cache resolver instead")
  boxStats(excludeAuthenticated: Boolean, combineAncestors: Boolean, minDate: SequelizeDate, maxDate: SequelizeDate, minValue: Float, openable: Boolean, purchasable: Boolean): [BoxStat]
  boxItemVariantStats(boxId: ID!, combineAncestors: Boolean, excluded: Boolean, minDate: SequelizeDate, maxDate: SequelizeDate): [BoxItemVariantStat]
  luckiestBoxOpening(marketId: ID, userId: ID): LuckiestBoxOpening!
  box(id: ID, marketId: ID, marketSlug: String, slug: String): Box
  boxes(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [BoxOrderBy], isFavorite: Boolean, itemId: ID, tags: [String], excludeTags: [String], name: String, boxName: String, itemName: String, minLevelRequired: Int, free: Boolean, availableFrom: SequelizeDate, availableUntil: SequelizeDate, statsProcessedAt: SequelizeDate, minValue: Float, maxValue: Float, type: BoxType, walletRestrictions: [WalletType], enabled: Boolean, purchasable: Boolean, openable: Boolean, sellable: Boolean, ancestorBoxId: ID, marketId: ID, marketSlug: String, itemIds: [ID!], minCost: Float, maxCost: Float, discounted: Boolean, dailyLimited: Boolean, slotTypes: [BoxSlotType!]): BoxConnection!
  favouriteBox(marketId: ID, userId: ID): FavouriteBox!
  calendarEntry(id: ID): CalendarEntry
  calendarEntries(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [CalendarEntryOrderBy], calendarId: ID, userId: ID): CalendarEntryConnection!
  calendar(id: ID): Calendar
  calendars(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [CalendarOrderBy]): CalendarConnection!
  casinoGameLobby(id: ID, slug: String): CasinoGameLobby
  casinoGameLobbies(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [CasinoGameLobbyOrderBy]): CasinoGameLobbyConnection!
  casinoGameProviderConfig(id: ID!): CasinoGameProviderConfig
  casinoGameProviderConfigs(after: String, before: String, devices: [Device], featureGroup: [CasinoGameFeatureGroup], first: PaginationAmount, last: PaginationAmount, orderBy: [CasinoGameProviderOrderBy], volatility: [CasinoGameVolatilityRating]): CasinoGameProviderConfigConnection
  casinoGameProvider(id: ID!): CasinoGameProvider
  casinoGameProviders(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [CasinoGameProviderOrderBy], subProviders: [CasinoGameProviderCode]): CasinoGameProviderConnection!
  casinoGameProviderTotalGames(lobbySlug: String, partialSearch: String, providers: [CasinoGameProviderCode!]): [CasinoGameProviderTotalGamesPayload]
  casinoGameRound(id: ID!): CasinoGameRound
  casinoGameRounds(after: String, before: String, first: PaginationAmount, fromDate: SequelizeDate, last: PaginationAmount, limit: Int, orderBy: [CasinoGameRoundOrderBy], page: Int, toDate: SequelizeDate, userId: ID): CasinoGameRoundConnection!
  casinoGameSession(id: ID!): CasinoGameSession
  casinoGameSessions(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [CasinoGameSessionOrderBy], userIds: [ID], startDate: SequelizeDate, endDate: SequelizeDate): CasinoGameSessionConnection!
  casinoGame(id: ID, slug: String): CasinoGame
  casinoGames(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [CasinoGameOrderBy], categories: [CasinoGameCategory], enabled: Boolean, isLive: Boolean, slug: String, studios: [CasinoGameProviderCode], title: String): CasinoGameConnection!
  countries: [Country]
  countryDetected: Country
  crashBetItem(id: ID!): CrashBetItem
  crashBetItems(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [CrashBetItemOrderBy]): CrashBetItemConnection!
  crashBet(id: ID!): CrashBet
  crashBets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [CrashBetOrderBy], gameId: ID, userId: ID): CrashBetConnection!
  crashBetItemVariants(after: String, before: String, first: PaginationAmount, last: PaginationAmount, marketId: ID!, minValue: Float!): CrashBetItemVariantConnection!
  crashBetStats(userId: ID!, limit: Int): CrashBetStats!
  crashGame(id: ID!): CrashGame
  crashGames(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [CrashGameOrderBy], status: CrashGameStatus): CrashGameConnection!
  cronJob(id: ID!): CronJob
  cronJobs(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [CronJobOrderBy]): CronJobConnection!
  cryptoAddress(id: ID): CryptoAddress
  cryptoAddresses(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [CryptoAddressOrderBy], paymentOptionIds: [ID!], userIds: [ID!]): CryptoAddressConnection!
  dashboard: Dashboard
  getCacheValue(key: String!): String
  getParsedCacheValue(key: String!): JSON
  diceBet(id: ID!): DiceBet
  diceBets(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [DiceBetOrderBy], maxAmount: Float, maxTotalPayout: Float, maxProfit: Float, minAmount: Float, minTotalPayout: Float, minProfit: Float, userId: ID, createdAtMinDate: SequelizeDate, createdAtMaxDate: SequelizeDate, gameTypes: [DiceGameType!]): DiceBetConnection!
  diceBetJackpotEntries(minAmount: Float!, minTotalPayout: Float!, createdAtMinDate: SequelizeDate!, createdAtMaxDate: SequelizeDate!, first: PaginationAmount!, gameType: DiceGameType!): [DiceBet!]!
  digitalCode(id: ID!): DigitalCode
  digitalCodes(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [DigitalCodeOrderBy], availableOnly: Boolean, code: String, itemVariantId: ID, userId: ID): DigitalCodeConnection!
  document(id: ID): Document
  documents(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [DocumentOrderBy], userId: ID): DocumentConnection!
  getDropCacheItems(input: GetDropCacheItemsInput): DropCacheItemsPayload
  waitingListEmail(id: ID): EmailWaitingList
  waitingListEmails(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [EmailWaitingListOrderBy], emails: [String], statuses: [EmailWaitingListStatus!]): EmailWaitingListConnection!
  getEosBlock(blockNumberOrId: String!): JSON
  getEosChainInfo: JSON
  getEosCurrentSimpleBlock: JSON
  getEosSimpleBlock(blockNumber: Int!): JSON
  exchangeRate(source: String, target: String): ExchangeRate
  exchangeRates(date: SequelizeDate, source: String, targets: [String!]): ExchangeRates
  exchange(id: ID!): Exchange
  exchanges(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [ExchangeOrderBy], userId: ID): ExchangeConnection!
  gameJackpotWinner(id: ID!): GameJackpotWinner
  gameJackpotWinners(gameId: String, gameJackpotId: String, after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [GameJackpotWinnerOrderBy]): GameJackpotWinnerConnection!
  gameJackpot(id: ID!): GameJackpot
  gameJackpots(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [GameJackpotOrderBy]): GameJackpotConnection!
  cachedLatestGames(gameId: ID, last: Int!): [Game!]!
  game(id: ID!): Game
  games(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [GameOrderBy], status: GameStatus, minRollId: ID, maxRollId: ID): GameConnection!
  gemstoneBoostActivation(id: ID!): GemstoneBoostActivation
  gemstoneBoostActivations(active: Boolean, after: String, before: String, first: PaginationAmount, gemstoneBoostId: ID, last: PaginationAmount, orderBy: [GemstoneBoostActivationOrderBy], teamIds: [ID!]): GemstoneBoostActivationConnection!
  gemstoneBoostInfo(gemstoneBoostId: ID, teamIds: [ID!]!, walletType: WalletType!): GemstoneBoostInfo!
  gemstoneGame(id: ID): GemstoneGame
  gemstoneGames(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [GemstoneGameOrderBy], createdAtMaxDate: SequelizeDate, createdAtMinDate: SequelizeDate, externalId: ID, externalModel: String, maxAmount: Float, maxBet: Float, minAmount: Float, minBet: Float, userId: ID, walletType: WalletType): GemstoneGameConnection!
  gemstoneGameLeaderboard(createdAtMaxDate: SequelizeDate, createdAtMinDate: SequelizeDate, limit: Int!, teamId: ID, useCache: Boolean, walletType: WalletType!): GemstoneGameLeaderboard!
  geoTrack(id: ID!): GeoTrack
  geoTracks(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [GeoTrackOrderBy], countries: [String!], createdAtMaxDate: SequelizeDate, createdAtMinDate: SequelizeDate, ips: [String!], userIds: [ID!]): GeoTrackConnection!
  geoTrackSummary(date: SequelizeDate): GeoTrackSummary
  geoTrackUserSummary(date: SequelizeDate, userId: ID!): GeoTrackUserSummary
  giftCardOption(id: ID!): GiftCardOption
  giftCardOptions(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [GiftCardOptionOrderBy], enabled: Boolean, providers: [GiftCardProvider!]): GiftCardOptionConnection!
  giveaway(id: ID!): Giveaway
  giveaways(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [GiveawayOrderBy], statuses: [GiveawayStatus!]): GiveawayConnection!
  inviteCode(id: ID!): InviteCode
  inviteCodes(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [InviteCodeOrderBy], code: String, userId: ID): InviteCodeConnection!
  itemCategory(id: ID!): ItemCategory
  itemCategories(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [ItemCategoryOrderBy], name: String): ItemCategoryConnection!
  itemVariantSizes(allowCached: Boolean, categoryId: ID, orderBy: ItemVariantSizeOrderBy): [ItemVariantSize]
  inventoryItemVariants(allowCached: Boolean, steamAppName: SteamAppName, steamId: String, userId: ID): Inventory!
  itemVariant(id: ID!): ItemVariant
  itemVariants(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [ItemVariantOrderBy], brand: String, name: String, minValue: Float, maxValue: Float, obtainable: Boolean, usable: Boolean, withdrawable: Boolean, type: ItemType, depositable: Boolean, categoryId: ID, itemId: ID, marketId: ID, purchasable: ItemPurchasable, canBuy: Boolean, minAvailableAt: SequelizeDate, maxAvailableAt: SequelizeDate, distinctDisplayValues: Boolean, distinctValues: Boolean, retailer: Retailer @deprecated(reason: "Use retailerIds"), retailers: [Retailer!] @deprecated(reason: "Use retailerIds"), retailerIds: [ID!], minExchangeRate: Float, maxExchangeRate: Float, minMarkup: Float, maxMarkup: Float, minTotalRequested: Int, minTotalUnfulfilled: Int, minValueAfterMarkup: Float, maxValueAfterMarkup: Float, minValueUpdatedAt: SequelizeDate, maxValueUpdatedAt: SequelizeDate, size: String): ItemVariantConnection!
  item(id: ID!): Item
  items(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [ItemOrderBy], name: String, minValue: Float, maxValue: Float, obtainable: Boolean, usable: Boolean, withdrawable: Boolean, type: ItemType, categoryId: ID, marketId: ID, distinctDisplayValues: Boolean, distinctValues: Boolean, minValueUpdatedAt: SequelizeDate, maxValueUpdatedAt: SequelizeDate, rarity: String, boxIds: [ID!], containedInAnyBox: Boolean, tagIds: [ItemTagInput!], retailerIds: [ID!], retailers: [Retailer!] @deprecated(reason: "Use retailerIds")): ItemConnection!
  jackpotWinningTicket(id: ID!): JackpotWinningTicket
  jackpotWinningTickets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [JackpotWinningTicketOrderBy], jackpotId: ID): JackpotWinningTicketConnection
  jackpot(id: ID!): Jackpot
  jackpots(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [JackpotOrderBy], won: Boolean, payoutType: JackpotPayoutType): JackpotConnection!
  jackpotLeaderboard(after: String, first: PaginationAmount, before: String, last: PaginationAmount, jackpotId: ID): JackpotLeaderboardConnection!
  location: Location
  detectedMarket: Market
  market(id: ID!): Market
  markets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MarketOrderBy], slug: String): MarketConnection!
  matchBettingGame(id: ID!): MatchBettingGame
  matchBettingGames(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MatchBettingGameOrderBy], externalIds: [String!], gameIds: [ID!], matchIds: [ID!], providers: [MatchBettingProvider!], statuses: [MatchBettingGameStatus!], videoGames: [MatchBettingVideoGame!]): MatchBettingGameConnection!
  matchBettingLeague(id: ID!): MatchBettingLeague
  matchBettingLeagues(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MatchBettingLeagueOrderBy], externalIds: [String!], externalSlugs: [String!], leagueIds: [ID!], name: String, providers: [MatchBettingProvider!], videoGames: [MatchBettingVideoGame!]): MatchBettingLeagueConnection!
  matchBettingMarket(id: ID!): MatchBettingMarket
  matchBettingMarkets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MatchBettingMarketOrderBy], externalIds: [String!], gameIds: [ID!], hasRollback: Boolean, marketIds: [ID!], matchIds: [ID!], matchName: String, name: String, providers: [MatchBettingProvider!], statuses: [MatchBettingMarketStatus!], types: [MatchBettingMarketType!], videoGames: [MatchBettingVideoGame!]): MatchBettingMarketConnection!
  matchBettingMatch(id: ID!): MatchBettingMatch
  matchBettingMatches(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MatchBettingMatchOrderBy], externalIds: [String!], externalSlugs: [String!], leagueIds: [ID!], matchBettingMarketIds: [ID!], matchIds: [ID!], name: String, providers: [MatchBettingProvider!], scheduledAtMaxDate: SequelizeDate, scheduledAtMinDate: SequelizeDate, serieIds: [ID!], statuses: [MatchBettingMatchStatus!], tournamentIds: [ID!], tournamentName: String, types: [MatchBettingMatchType!], videoGames: [MatchBettingVideoGame!]): MatchBettingMatchConnection!
  matchBettingPlayer(id: ID!): MatchBettingPlayer
  matchBettingPlayers(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MatchBettingPlayerOrderBy], currentTeamIds: [ID!], externalIds: [String!], externalSlugs: [String!], name: String, playerIds: [ID!], providers: [MatchBettingProvider!]): MatchBettingPlayerConnection!
  matchBettingSerie(id: ID!): MatchBettingSerie
  matchBettingSeries(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MatchBettingSerieOrderBy], externalIds: [String!], externalSlugs: [String!], fullName: String, leagueIds: [ID!], providers: [MatchBettingProvider!], serieIds: [ID!], videoGames: [MatchBettingVideoGame!]): MatchBettingSerieConnection!
  matchBettingSlip(id: ID!): MatchBettingSlip
  matchBettingSlips(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MatchBettingSlipOrderBy], createdAtMaxDate: SequelizeDate, createdAtMinDate: SequelizeDate, hasRollback: Boolean, matchBettingGameId: ID, matchBettingMarketId: ID, matchBettingMarketName: String, matchBettingMatchId: ID, matchBettingMatchName: String, matchBettingTournamentId: ID, matchBettingTournamentName: String, providers: [MatchBettingProvider!], slipIds: [ID!], statuses: [MatchBettingSlipStatus!], types: [MatchBettingSlipType!], userIds: [ID!]): MatchBettingSlipConnection!
  matchBettingTeam(id: ID!): MatchBettingTeam
  matchBettingTeams(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MatchBettingTeamOrderBy], externalIds: [String!], externalSlugs: [String!], name: String, providers: [MatchBettingProvider!], teamIds: [ID!]): MatchBettingTeamConnection!
  matchBettingTournament(id: ID!): MatchBettingTournament
  matchBettingTournaments(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MatchBettingTournamentOrderBy], externalIds: [String!], externalSlugs: [String!], leagueIds: [ID!], name: String, providers: [MatchBettingProvider!], serieIds: [ID!], tournamentIds: [ID!], videoGames: [MatchBettingVideoGame!]): MatchBettingTournamentConnection!
  message(id: ID!): Message
  messages(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [MessageOrderBy], channel: String, channels: [String], showDeleted: Boolean, userId: ID): MessageConnection!
  cachedMessages(first: PaginationAmount, channels: [String]): MessageConnection!
  note(id: ID!): Note
  notes(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [NoteOrderBy], externalId: ID, externalModel: ExternalModel, creatorId: ID, userId: ID): NoteConnection!
  notificationMessage(id: ID!): NotificationMessage
  notificationMessages(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [NotificationMessageOrderBy], notificationId: ID, notificationOwnerId: ID, unreadOnly: Boolean): NotificationMessageConnection!
  notification(id: ID!): Notification
  notifications(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [NotificationOrderBy], externalId: Int, externalModel: String, type: NotificationType, unreadOnly: Boolean, userId: ID, withMessages: Boolean): NotificationConnection!
  orderNote(id: ID!): OrderNote
  orderNotes(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [OrderNoteOrderBy], orderId: ID!, creatorId: ID): OrderNoteConnection!
  order(id: ID!): Order
  orders(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [OrderOrderBy], userId: ID, creatorId: ID, createdAtMinDate: SequelizeDate, createdAtMaxDate: SequelizeDate, retailer: Retailer @deprecated(reason: "Use retailerId"), retailerId: ID, itemName: String): OrderConnection!
  retailerDeliveryStats(minDate: SequelizeDate, maxDate: SequelizeDate): RetailerDeliveryStatsResponse
  paymentOption(id: ID!): PaymentOption
  paymentOptions(action: PaymentOptionAction, countryCode: String, enabled: Boolean, visible: Boolean): [PaymentOption]
  plinkoBet(id: ID!): PlinkoBet
  plinkoBets(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [PlinkoBetOrderBy], bigWin: Boolean, createdAtMaxDate: SequelizeDate, createdAtMinDate: SequelizeDate, maxBet: Float, maxTotalBet: Float, maxTotalPayout: Float, maxUserProfit: Float, minBet: Float, minTotalBet: Float, minTotalPayout: Float, minUserProfit: Float, riskModes: [PlinkoBetRiskMode!], userIds: [ID!]): PlinkoBetConnection!
  plinkoBetSlots: PlinkoBetSlotsPayload!
  pollOption(id: ID!): PollOption
  pollOptions(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [PollOptionOrderBy], pollId: ID): PollOptionConnection!
  poll(id: ID!): Poll
  polls(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [PollOrderBy], active: Boolean, status: PollStatus, userLevel: Int): PollConnection!
  promoCode(id: ID!): PromoCode
  promoCodes(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [PromoCodeOrderBy], affiliateUserId: ID, expired: Boolean, code: String, type: PromoCodeType, createdAt: String, marketId: ID, walletType: WalletType): PromoCodeConnection!
  promoCodeTimer(code: String!, amount: Float!): PromoCodeTimer!
  promotions: [Promotion!]
  proxy(id: ID): Proxy
  proxies(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [ProxyOrderBy]): ProxyConnection!
  pvpBet(id: ID!): PvpBet
  pvpBets(after: String, first: PaginationAmountLarge, before: String, last: PaginationAmountLarge, orderBy: [PvpBetOrderBy], bigWin: Boolean, gameType: PvpGameType, gameTypes: [PvpGameType!], pvpBetId: ID, pvpGameId: ID, pvpRoundId: ID, statuses: [PvpBetStatus!], userId: ID): PvpBetConnection!
  pvpBot(id: ID!): PvpBot
  pvpBots(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [PvpBotOrderBy], currencies: [String!], pvpBotIds: [ID!], statuses: [PvpBotStatus!], userIds: [ID!]): PvpBotConnection!
  pvpGame(id: ID!): PvpGame
  pvpGames(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [PvpGameOrderBy], createdAtMaxDate: SequelizeDate, createdAtMinDate: SequelizeDate, hasPvpBot: Boolean, pvpGameId: ID, statuses: [PvpGameStatus!], strategies: [PvpGameStrategy!], type: PvpGameType, types: [PvpGameType!], userId: ID, isMultiplierBoxGame: Boolean @deprecated(reason: "use multiplierModes"), multiplierModes: [PvpGameMultiplierMode!]): PvpGameConnection!
  pvpRound(id: ID!): PvpRound
  pvpRounds(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [PvpRoundOrderBy], gameType: PvpGameType, gameTypes: [PvpGameType!], hasPvpBot: Boolean, minBiggestWinValue: Float, pvpGameId: ID, pvpRoundId: ID, statuses: [PvpRoundStatus!], userId: ID): PvpRoundConnection!
  rankUpGame(id: ID!): RankUpGame
  rankUpGames(first: PaginationAmount, last: PaginationAmount, after: String, before: String, orderBy: [RankUpGameOrderBy], id: ID, userId: ID): RankUpGameConnection
  node(id: ID!): Node
  retailer(id: ID!): RetailerType
  retailers(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [RetailerOrderBy], code: String, name: String): RetailerConnection!
  roll(id: ID!): Roll
  rolls(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [RollOrderBy], game: GameType): RollConnection!
  rollHistory(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: RollOrderBy, game: GameType): [RollHistory]!
  commitVersion: CommitVersion
  onlineCount: Int
  time: SequelizeDate
  seed(id: ID!): Seed
  seeds(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [SeedOrderBy], userId: ID!, type: SeedType): SeedConnection!
  setting(key: String!): Setting
  settingsByKeys(keys: [String]!): [Setting!]
  settings: [Setting!]
  socialStory(id: ID!): SocialStory!
  socialStories(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [SocialStoryOrderBy], width: Int, theme: SocialStoryTheme = LIGHT, providers: [SocialStoryProvider!]): SocialStoryConnection!
  steamAsset(id: ID!): SteamAsset
  steamAssets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [SteamAssetOrderBy], itemVariantId: ID, steamBotId: ID, incomingSteamOfferId: ID, outgoingSteamOfferId: ID, minLockExpiresAt: SequelizeDate, maxLockExpiresAt: SequelizeDate): SteamAssetConnection!
  steamBot(id: ID!): SteamBot
  steamBots(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [SteamBotOrderBy], steamBotId: ID, username: String, steamId: String, banned: Boolean, steamGame: Int, type: SteamBotType): SteamBotConnection!
  steamOfferItemVariant(id: ID!): SteamOfferItemVariant
  steamOfferItemVariants(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [SteamOfferItemVariantOrderBy], steamOfferId: ID): SteamOfferItemVariantConnection!
  steamOffer(id: ID!): SteamOffer
  steamOffers(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [SteamOfferOrderBy], steamOfferId: ID, userId: ID, steamBotId: ID, tradeId: ID, tradeOfferId: String, state: SteamOfferState): SteamOfferConnection!
  steam2FACode(sharedSecret: String!): String
  steamInventory(allowCached: Boolean!, onlyResponse: Boolean!, steamAppName: SteamAppName!, userId: ID!): JSON!
  steamUserTradeHistory(userId: ID!, since: Int, withSteamId: String, onlyCompleted: Boolean): SteamUserTradeHistory!
  tag(id: ID!): Tag
  tags(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [TagOrderBy], name: String, visible: Boolean): TagConnection!
  team(id: ID!): Team
  teams(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [TeamOrderBy]): TeamConnection!
  ticket(id: ID!): Ticket
  tickets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [TicketOrderBy], jackpotId: ID, userId: ID): TicketConnection!
  getTileOpeningRewardAmount(userId: ID!): GetTileOpeningRewardAmountPayload!
  tileOpening(id: ID): TileOpening
  tileOpenings(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [TileOpeningOrderBy], tileSettingId: ID, userId: ID): TileOpeningConnection!
  tileSetting(id: ID): TileSetting
  tileSettings(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [TileSettingOrderBy], marketIds: [ID]): TileSettingConnection!
  tradeItem(id: ID!): TradeItem
  tradeItems(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [TradeItemOrderBy], tradeId: ID): TradeItemConnection!
  trade(id: ID!): Trade
  trades(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [TradeOrderBy], tradeId: ID, userId: ID, depositorSteamId: String, withdrawerSteamId: String, steamAppName: SteamAppName, status: TradeStatus, minTotalValue: Float, maxTotalValue: Float, marketName: String, statuses: [TradeStatus!], updatedAtMinDate: SequelizeDate, updatedAtMaxDate: SequelizeDate, maxMarkupPercent: Float, bySupplier: Boolean): TradeConnection!
  transaction(id: ID, externalId: ID): Transaction
  transactions(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [TransactionOrderBy], createdAfter: String @deprecated(reason: "Use 'minDate'"), createdBefore: String @deprecated(reason: "Use 'maxDate'"), minDate: String, maxDate: String, promoCodeId: ID, provider: PaymentProvider, providers: [PaymentProvider!], status: String @deprecated(reason: "Use 'statuses'"), statuses: [TransactionStatus!], types: [TransactionType!], transactionId: ID, userId: ID, externalIds: [String!]): TransactionConnection!
  trigger(id: ID!): Trigger
  triggers(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [TriggerOrderBy], enabled: Boolean, status: TriggerStatus, hasGiveaway: Boolean): TriggerConnection!
  userAchievement(id: ID!): UserAchievement
  userAchievements(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserAchievementOrderBy], achievementIds: [ID!], types: [AchievementType!], userAchievementIds: [ID!], userId: ID, userIds: [ID!]): UserAchievementConnection
  userAddress(id: ID): UserAddress
  userAddresses(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserAddressOrderBy], userIds: [ID!]): UserAddressConnection!
  userAsset(id: ID!): UserAsset
  userAssets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, userId: ID, orderBy: [UserAssetOrderBy]): UserAssetConnection
  userBox(id: ID!): UserBox
  userBoxes(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserBoxOrderBy], categoryId: ID, userId: ID, name: String, status: [UserBoxStatus]): UserBoxConnection!
  userCommunication(id: ID!): UserCommunication
  userCommunications(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserCommunicationOrderBy], mutedUserIds: [ID!], userId: ID): UserCommunicationConnection!
  userGiveaway(id: ID): UserGiveaway
  userGiveaways(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [UserGiveawayOrderBy], giveawayId: ID, userId: ID): UserGiveawayConnection!
  userItem(id: ID!): UserItem
  userItems(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserItemOrderBy], categoryId: ID, retailer: [Retailer!] @deprecated(reason: "Use retailerIds"), retailerIds: [ID!], userId: ID, name: String, status: [UserItemStatus], itemType: [ItemType!], updatedAtMinDate: SequelizeDate, updatedAtMaxDate: SequelizeDate, exchangedForBalance: Boolean): UserItemConnection!
  userPollOption(id: ID!): UserPollOption
  userPollOptions(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [UserPollOptionOrderBy], pollId: ID, pollOptionId: ID, userId: ID): UserPollOptionConnection!
  userProgressChange(id: ID!): UserProgressChange
  userProgressChanges(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [UserProgressChangeOrderBy], sources: [UserProgressSource!], userId: ID): UserProgressChangeConnection
  userProgressChangesSummary(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [UserProgressChangeSummaryOrderBy], maxDate: SequelizeDate, minDate: SequelizeDate, userId: ID): UserProgressChangesSummaryConnection!
  userPromoCodes(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserPromoCodeOrderBy], code: String, promoCodeId: ID, userId: ID): UserPromoCodeConnection!
  userStat(id: ID!): UserStat
  userStats(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserStatOrderBy], userId: ID, userStatId: ID, marketId: ID, excluded: Boolean, includeOwnersAndBots: Boolean, stat: [UserStatStat!], type: [UserStatType!], dateFrom: SequelizeDate, dateTo: SequelizeDate, excludeBannedUsers: Boolean): UserStatConnection!
  userTierAsset(id: ID!): UserTierAsset
  userTierAssets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserTierAssetOrderBy], enabled: Boolean, rank: Int, userId: ID): UserTierAssetConnection
  getUserTierAssetsStatuses(tierRank: ID!): [GetUserTierAssetsStatusesPayload]
  userTier(id: ID!): UserTier
  userTiers(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserTierOrderBy]): UserTierConnection!
  currentUser: User
  sessionHash: String
  user(id: ID!): User
  users(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserOrderBy], affiliateTierId: ID, affiliateUserId: ID, userId: ID, name: String, permissions: Int, roles: [UserRole], email: String, steamId: String, supplier: Boolean, trader: Boolean, minTotalCommissionEarnt: Float, maxTotalCommissionEarnt: Float): UserConnection!
  userRewards(userId: ID!, minDate: SequelizeDate, maxDate: SequelizeDate): UserReward
  userStatistics(userId: ID!, minDate: SequelizeDate, maxDate: SequelizeDate): UserStatistics
  walletChange(id: ID!): WalletChange
  walletChanges(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [WalletChangeOrderBy], createdAtMaxDate: SequelizeDate, createdAtMinDate: SequelizeDate, type: [WalletChangeType!], userId: ID, walletIds: [ID!]): WalletChangeConnection!
  walletChangesSummary(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [WalletChangesSummaryOrderBy], maxDate: SequelizeDate, minDate: SequelizeDate, userId: ID): WalletChangesSummaryConnection!
  wallet(id: ID!): Wallet
  wallets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [WalletOrderBy], userId: ID, name: [WalletType!], minAmount: Float, claimable: Boolean): WalletConnection!
  waxPeerItems(after: String, first: PaginationAmount, orderBy: WaxPeerItemOrderBy, discount: Int, from: Float, marketHashName: String, markup: Int, maxValue: Float, minValue: Float): WaxPeerItemConnection!
  waxPeerTrade(id: ID!): WaxPeerTrade
  waxPeerTrades(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [WaxPeerTradeOrderBy], externalId: String, externalStatus: WaxPeerTradeExternalStatus, itemVariantId: ID, status: WaxPeerTradeStatus, userId: ID, waxPeerTradeId: ID): WaxPeerTradeConnection!
  wishlist(id: ID!): Wishlist
  wishlists(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [WishlistOrderBy], userId: ID): WishlistConnection!
  withdrawalRequest(id: ID!): WithdrawalRequest
  withdrawalRequests(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [WithdrawalRequestOrderBy], userId: ID, createdFrom: String, status: WithdrawalRequestStatus): WithdrawalRequestConnection!
  zbtMarketplaceItems(steamAppName: SteamAppName!, after: String, first: PaginationAmount, marketHashName: String, maxValue: Float, minValue: Float, orderBy: ZbtMarketplaceItemOrderBy): ZbtMarketplaceItemConnection!
  zbtTrade(id: ID!): ZbtTrade
  zbtTrades(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [ZbtTradeOrderBy], externalId: String, externalStatus: ZbtTradeExternalStatus, itemVariantId: ID, status: ZbtTradeStatus, userId: ID, zbtTradeId: ID): ZbtTradeConnection!
  zincOrder(id: ID!): ZincOrder
  zincOrders(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [ZincOrderOrderBy], creatorId: ID, orderId: ID, zincOrderId: ID, createdAtMinDate: SequelizeDate, createdAtMaxDate: SequelizeDate): ZincOrderConnection!
  zincProductSearch(input: ZincProductSearchInput!): ZincProductSearchPayload!
}

type Mutation {
  createAchievement(input: CreateAchievementInput!): CreateAchievementPayload!
  updateAchievement(id: ID!, input: UpdateAchievementInput!): UpdateAchievementPayload!
  deleteAchievement(id: ID!): DeleteAchievementPayload!
  flushAchievementCache(input: FlushAchievementCacheInput): FlushAchievementCachePayload
  cancelAffiliateLoan(input: AffiliateLoanCancelInput!): CreateLoanRequestPayload!
  requestAffiliateLoan(input: AffiliateLoanRequestInput!): CreateLoanRequestPayload!
  respondToAffiliateLoan(input: AffiliateLoanResponseToInput!): UpdateLoanRequestPayload!
  cleanAffiliatePromoImages(input: AffiliateSecretInput!): AffiliateUrlsPayload
  createAffiliatePromoImage(input: AffiliatePromoImageInput!): AffiliateUrlPayload
  createAffiliateReports(input: AffiliateReportJobInput): CreateAffiliateReportsJobPayload
  createAffiliateTier(input: CreateAffiliateTierInput!): AffiliateTierPayload!
  deleteAffiliateTier(input: DeleteAffiliateTierInput!): AffiliateTierPayload!
  updateAffiliateTier(input: UpdateAffiliateTierInput!): AffiliateTierPayload!
  createAsset(input: CreateAssetInput!): Asset
  deleteAsset(id: ID!): Asset
  createBet(input: CreateBetInput!): CreateBetPayload
  refreshCachedGameBets(input: RefreshCachedGameBetsInput!): RefreshCachedGameBetsPayload
  openBox(input: OpenBoxInput!): CreateBoxOpeningPayload
  addRefreshBoxOpeningStreamTasks(input: AddRefreshBoxOpeningStreamTasksInput): AddRefreshBoxOpeningStreamTasks!
  refreshBoxOpeningStream(input: RefreshBoxOpeningStreamInput): RefreshBoxOpeningStream!
  createBox(input: CreateBoxInput!): CreateBoxPayload
  toggleFavoriteBox(input: ToggleFavoriteBoxInput!): ToggleFavoriteBoxPayload!
  generateBoxesCsv(input: GenerateBoxesCsvInput!): GenerateBoxesCsvPayload!
  recalculateBoxStatistics(input: RecalculateBoxStatisticsInput!): RecalculateBoxStatisticsPayload!
  refreshBoxes(input: RefreshBoxesInput!): RefreshBoxesPayload!
  updateBox(input: UpdateBoxInput!): UpdateBoxPayload
  updateBoxOrder(input: UpdateBoxOrderInput!): UpdateBoxOrderPayload!
  createCalendarEntry(input: CreateCalendarEntryInput!): CreateCalendarEntryPayload
  createCalendar(input: CreateCalendarInput!): CreateCalendarPayload
  deleteCalendar(input: DeleteCalendarInput!): DeleteCalendarPayload
  updateCalendar(input: UpdateCalendarInput!): UpdateCalendarPayload
  createCasinoGameLobby(input: CreateCasinoGameLobbyInput!): CreateCasinoGameLobbyPayload
  updateCasinoGameLobby(input: UpdateCasinoGameLobbyInput!): UpdateCasinoGameLobbyPayload
  createCasinoGameProviderConfig(input: CreateCasinoGameProviderConfigInput!): CasinoGameProviderConfig
  updateCasinoGameProviderConfig(input: UpdateCasinoGameProviderConfigInput!): CasinoGameProviderConfig
  addCasinoGameProviderGames(input: AddCasinoGameProviderGamesInput!): AddCasinoGameProviderGamesPayload
  createCasinoGameProvider(input: CreateCasinoGameProviderInput!): CasinoGameProvider
  updateCasinoGameProvider(input: UpdateCasinoGameProviderInput!): CasinoGameProvider
  startCasinoGameSession(input: StartCasinoGameSessionInput!): CasinoGameSessionPayload
  createCasinoGame(input: CreateCasinoGameInput!): CasinoGame
  resolveCasinoGameImages(casinoGameId: ID, studioCodes: [CasinoGameProviderCode!]): ResolveCasinoGameImagesPayload
  updateCasinoGame(input: UpdateCasinoGameInput!): CasinoGame
  createCrashBet(input: CreateCrashBetInput!): CreateCrashBetPayload
  exitCrash(input: ExitCrashInput!): ExitCrashPayload
  createCronJob(input: CreateCronJobInput!): CreateCronJobPayload
  deleteCronJob(input: DeleteCronJobInput!): DeleteCronJobPayload
  pauseCronJob(input: PauseCronJobInput!): PauseCronJobPayload
  resumeCronJob(input: ResumeCronJobInput!): ResumeCronJobPayload
  createCryptoAddress(input: CreateCryptoAddressInput!): CryptoAddressPayload!
  deleteCryptoAddress(input: DeleteCryptoAddressInput!): CryptoAddressPayload!
  updateCryptoAddress(input: UpdateCryptoAddressInput!): CryptoAddressPayload!
  deleteCacheKey(key: String!): Int
  createDiceBets(input: CreateDiceBetsInput!): CreateDiceBetsPayload
  createDigitalCodes(input: CreateDigitalCodesInput!): CreateDigitalCodePayload
  deleteDigitalCode(id: ID!): DeleteDigitalCodePayload!
  createDocument(input: CreateDocumentInput!): CreateDocumentPayload
  updateDocument(input: UpdateDocumentInput!): UpdateDocumentPayload
  deleteDocument(input: DeleteDocumentInput!): DeleteDocumentPayload
  refreshDropCacheItems: Boolean
  addEmailToWaitingList(input: EmailWaitingListInput!): EmailWaitingListPayload
  createEmail(input: CreateEmailInput!): CreateEmailPayload
  sendSelfExclusionExpiredEmail(input: SendSelfExclusionExpiredEmailInput!): SendSelfExclusionExpiredEmailPayload
  resubscribeUserToAllMarketingEmails(input: ResubscribeUserToAllMarketingEmailsInput!): ResubscribeUserToAllMarketingEmailsPayload
  updateExchangeRates(input: UpdateExchangeRatesInput!): UpdateExchangeRatesPayload
  createExchange(input: CreateExchangeInput!): CreateExchangePayload
  forgotPassword(input: ForgotPasswordInput!): ForgotPasswordPayload
  completeGameJackpot(input: CompleteGameJackpotInput!): CompleteGameJackpotPayload!
  createGameMessage(input: CreateGameMessageInput!): CreateGameMessagePayload
  createPvpGameMessage(input: CreatePvpGameMessageInput!): CreatePvpGameMessagePayload
  refreshCachedLatestGames(input: RefreshCachedLatestGamesInput!): RefreshCachedLatestGamesPayload
  finishGame(input: FinishGameInput!): FinishGamePayload
  createGemstoneBoost(input: CreateGemstoneBoostInput!): CreateGemstoneBoostPayload!
  updateGemstoneBoost(input: UpdateGemstoneBoostInput!): UpdateGemstoneBoostPayload!
  createGiftCardOption(input: CreateGiftCardOptionInput!): CreateGiftCardOptionPayload
  updateGiftCardOption(input: UpdateGiftCardOptionInput!): UpdateGiftCardOptionPayload
  createGiveaway(input: CreateGiveawayInput!): CreateGiveawayPayload
  joinGiveaway(input: JoinGiveawayInput!): CreateUserGiveawayPayload
  updateGiveaway(input: UpdateGiveawayInput!): UpdateGiveawayPayload
  announceGiveaway(input: AnnounceGiveawayInput!): AnnounceGiveawayPayload
  createInviteCode(input: CreateInviteCodeInput!): CreateInviteCodePayload
  updateInviteCode(input: UpdateInviteCodeInput!): UpdateInviteCodePayload
  createItemCategory(input: CreateItemCategoryInput): CreateCategoryPayload
  updateItemCategory(input: UpdateItemCategoryInput): UpdateCategoryPayload
  deleteItemCategory(input: DeleteItemCategoryInput): CreateCategoryPayload
  createItemVariant(input: CreateItemVariantInput!): CreateItemVariantPayload
  updateItemVariant(input: UpdateItemVariantInput!): UpdateItemVariantPayload
  deleteItemVariant(input: DeleteItemVariantInput!): DeleteItemVariantPayload
  updateItemVariants(input: [UpdateItemVariantInput!]!, secret: String, userId: ID): UpdateItemVariantsPayload
  addUpdateItemVariantsTask(input: [UpdateItemVariantInput!]!): AddUpdateItemVariantsTaskInputPayload
  addSyncItemPricesTasks(input: AddSyncItemPricesTasksInput!): AddSyncItemPricesTasksPayload
  cloneItem(input: CloneItemInput!): CloneItemPayload
  createItem(input: CreateItemInput!): CreateItemPayload
  createItems(input: [CreateItemInput!]!): CreateItemsPayload
  flattenItem(input: FlattenItemInput!): FlattenItemPayload
  syncItemPrices(input: SyncItemPricesInput!): SyncItemPricesPayload
  syncNewItems(input: SyncNewItemsInput!): SyncNewItemsPayload
  updateItem(input: UpdateItemInput!): UpdateItemPayload
  updateItemDisplayValues(input: UpdateItemDisplayValuesInput!): UpdateItemDisplayValuesPayload
  updateItemExchangeRates(input: UpdateItemExchangeRatesInput!): UpdateItemExchangeRatesPayload
  updateItemMarkups(input: UpdateItemMarkupsInput!): UpdateItemMarkupsPayload
  updateItemValues(input: UpdateItemValuesInput!): UpdateItemValuesPayload
  createJackpot(input: CreateJackpotInput!): CreateJackpotPayload
  payoutJackpot: PayoutJackpotPayload
  payoutJackpotTicket(input: PayoutTicketInput!): PayoutJackpotTicketPayload
  recalculateJackpot(input: RecalculateJackpotInput!): RecalculateJackpotPayload
  recalculateJackpotTickets(input: RecalculateJackpotTicketsInput!): RecalculateJackpotTicketsPayload
  updateJackpot(input: UpdateJackpotInput!): UpdateJackpotPayload
  completeJackpot(input: CompleteJackpotInput!): CompleteJackpotPayload
  createMarket(input: CreateUpdateMarketInput!): CreateMarketPayload
  updateMarket(id: ID!, input: CreateUpdateMarketInput!): UpdateMarketPayload
  deleteMarket(id: ID!): DeleteMarketPayload
  cloneMarket(id: ID!, input: CreateUpdateMarketInput!): CloneMarketPayload
  processMatchBettingMarket(input: ProcessMatchBettingMarketInput!): ProcessMatchBettingMarketPayload
  createMatchBettingMatchesFromProvider(input: CreateMatchBettingMatchesFromProviderInput!): CreateMatchBettingMatchFromProviderPayload
  processSettledMatchBettingMatch(input: ProcessSettledMatchBettingMatchInput!): ProcessSettledMatchBettingMatchPayload
  refreshMatchBettingMatchesStats(input: RefreshMatchBettingMatchesStatsInput!): RefreshMatchBettingMatchesStatsPayload
  scheduleSyncForMatchBettingMatches(input: ScheduleSyncForMatchBettingMatchesInput!): ScheduleSyncForMatchBettingMatchesPayload
  syncMatchBettingMatches(input: SyncMatchBettingMatchesInput!): SyncMatchBettingMatchesPayload
  generateMatchBettingReport(input: GenerateMatchBettingReportInput!): GenerateMatchBettingReportPayload
  completeMatchBettingSlip(input: CompleteMatchBettingSlipInput!): CompleteMatchBettingSlipPayload
  createMatchBettingSlip(input: CreateMatchBettingSlipInput!): CreateMatchBettingSlipPayload
  updateMatchBettingSlip(input: UpdateMatchBettingSlipInput!): UpdateMatchBettingSlipPayload
  createMessage(input: CreateMessageInput!): CreateMessagePayload
  deleteMessages(input: DeleteMessagesInput!): DeleteMessagesPayload
  createNote(input: CreateNoteInput!): CreateNotePayload
  createNotificationMessage(input: CreateNotificationMessageInput!): CreateNotificationMessagePayload
  markNotificationMessagesAsRead(input: MarkNotificationMessagesAsReadInput!): MarkNotificationMessagesAsReadPayload
  markNotificationsAsRead(input: MarkNotificationsAsReadInput!): MarkNotificationsAsReadPayload
  createOrderNote(input: CreateOrderNoteInput!): CreateOrderNotePayload
  createOrder(input: CreateOrderInput!): CreateOrderPayload
  updateOrder(input: UpdateOrderInput!): UpdateOrderPayload
  deleteOrder(input: DeleteOrderInput!): DeleteOrderPayload
  sendOrderDeliveredEmail(input: SendOrderDeliveredEmailInput!): SendOrderDeliveredEmailPayload
  createPaymentOption(input: CreatePaymentOptionInput!): CreatePaymentOptionPayload!
  updatePaymentOption(input: UpdatePaymentOptionInput!): UpdatePaymentOptionPayload!
  deletePaymentOption(input: DeletePaymentOptionInput!): DeletePaymentOptionPayload!
  createPlinkoBet(input: CreatePlinkoBetInput!): CreatePlinkoBetPayload @deprecated(reason: "Use 'createPlinkoBets' instead")
  createPlinkoBets(input: CreatePlinkoBetsInput!): CreatePlinkoBetsPayload
  refreshPlinkoBetSlots: PlinkoBetSlotsPayload
  updatePollOption(input: UpdatePollOptionInput!): UpdatePollOptionPayload
  selectPollOptions(input: SelectPollOptionsInput!): SelectPollOptionsPayload
  createPoll(input: CreatePollInput!): CreatePollPayload
  deletePoll(input: DeletePollInput!): DeletePollPayload
  exportUserPollOptions(input: ExportUserPollOptionsInput!): ExportUserPollOptionsPayload
  updatePoll(input: UpdatePollInput!): UpdatePollPayload
  updatePollStatus(input: UpdatePollStatusInput!): UpdatePollPayload
  createAffiliatePromoCode(input: CreateAffiliatePromoCodeInput): CreateAffiliatePromoCodePayload!
  updateAffiliatePromoCode(input: UpdateAffiliatePromoCodeInput): UpdateAffiliatePromoCodePayload!
  createPromoCodes(input: CreatePromoCodeInput): CreatePromoCodesPayload!
  createGiftCardPromoCodes(input: CreateGiftCardPromoCodesInput!): CreatePromoCodesPayload!
  deletePromoCode(input: DeletePromoCodeInput): PromoCodePayload!
  updatePromoCode(input: UpdatePromoCodeInput): PromoCodePayload!
  usePromoCode(input: UsePromoCodeInput!): PromoCodePayload!
  createProxy(input: CreateProxyInput!): CreateProxyPayload
  deleteProxy(input: DeleteProxyInput!): DeleteProxyPayload
  updateProxy(input: UpdateProxyInput!): UpdateProxyPayload
  callPvpBot(input: CallPvpBotInput!): CallPvpBotPayload
  callPvpBotForRematch(input: CallPvpBotForRematchInput!): CallPvpBotForRematchPayload
  createPvpBot(input: CreatePvpBotInput!): CreatePvpBotPayload
  updatePvpBot(input: UpdatePvpBotInput!): UpdatePvpBotPayload
  cleanUpStalePvpGames(input: CleanUpStalePvpGamesInput!): CleanUpStalePvpGamesPayload
  createPvpGame(input: CreatePvpGameInput!): CreatePvpGamePayload
  exitPvpGame(input: ExitPvpGameInput!): ExitPvpGamePayload
  exitAllActivePvpGames: ExitAllActivePvpGamesPayload
  finishAllActivePvpGames: FinishAllActivePvpGamesPayload
  joinPvpGame(input: JoinPvpGameInput!): JoinPvpGamePayload
  playPvpGame(input: PlayPvpGameInput!): PlayPvpGamePayload
  refundStuckPvpGameBets(input: RefundStuckPvpGameBetsInput!): RefundStuckPvpGameBetsPayload
  createPvpRound(input: CreatePvpRoundInput!): CreatePvpRoundPayload
  createRankUpGame(input: CreateRankUpGameInput!): RankUpGame
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload
  createRetailer(input: CreateRetailerInput!): RetailerPayload!
  deleteRetailer(input: DeleteRetailerInput!): RetailerPayload!
  updateRetailer(input: UpdateRetailerInput!): RetailerPayload!
  changeSeed(input: ChangeSeedInput!): ChangeSeedPayload
  updateSetting(input: UpdateSettingInput!): UpdateSettingPayload
  flushSettingCache(input: FlushSettingInput): FlushSettingCachePayload
  createSocialStory(input: CreateSocialStoryInput!): CreateSocialStoryPayload!
  updateSocialStory(input: UpdateSocialStoryInput!): UpdateSocialStoryPayload!
  deleteSocialStory(input: DeleteSocialStoryInput!): DeleteSocialStoryPayload!
  banSteamBotAssets(input: BanSteamBotAssetsInput!): BanSteamBotAssetsPayload
  updateAvailableAssets(input: UpdateAvailableAssetsInput!): UpdateAvailableAssetsPayload
  checkSteamBotActivity(input: CheckSteamBotActivityInput!): CheckSteamBotActivityPlayload!
  createSteamBot(input: CreateUpdateSteamBotInput!): CreateSteamBotPayload!
  createSteamBots(input: [CreateUpdateSteamBotInput!]!): CreateSteamBotsPayload!
  updateSteamBot(id: ID!, input: CreateUpdateSteamBotInput!): UpdateSteamBotPayload!
  deleteSteamBot(id: ID!): DeleteSteamBotPayload!
  wakeUpSteamBot(id: ID!): WakeUpSteamBotPayload!
  sleepSteamBot(id: ID!): SleepSteamBotPayload!
  deleteSteamOffer(id: ID!): DeleteSteamOfferPayload
  readySteamOffer(input: ReadySteamOfferInput!): ReadySteamOfferPayload!
  createSteamOffers(input: CreateSteamOffersInput!): CreateSteamOffersPayload!
  updateSteamStatus(input: UpdateSteamStatusInput!): UpdateSteamStatusPayload
  createSupportTicket(input: CreateSupportTicketInput!): CreateSupportTicketPayload
  createTag(input: CreateTagInput): CreateTagPayload
  updateTag(input: UpdateTagInput): UpdateTagPayload
  deleteTag(input: DeleteTagInput): DeleteTagPayload
  purgeTaskQueue(input: PurgeTaskQueueInput!): PurgeTaskQueuePayload
  createTickets(input: CreateTicketsInput!): CreateTicketsPayload
  openTile: OpenTilePayload!
  createTileSetting(input: CreateTileSettingInput!): TileSettingPayload!
  deleteTileSetting(input: DeleteTileSettingInput!): TileSettingPayload!
  updateTileSetting(input: UpdateTileSettingInput!): TileSettingPayload!
  autoJoinTrade(input: AutoJoinTradeInput!): AutoJoinTradePayload
  cancelTrade(input: CancelTradeInput!): CancelTradePayload
  cleanUpTrades(input: CleanUpTradesInput!): CleanUpTradesPayload
  cleanUpCooldownTrades(input: CleanUpCooldownTradesInput!): CleanUpCooldownTradesPayload
  completeTrade(input: CompleteTradeInput!): CompleteTradePayload
  createTrade(input: CreateTradeInput!): CreateTradePayload @deprecated(reason: "Use createTrades mutation instead")
  createTrades(input: CreateTradesInput!): CreateTradesPayload
  generateTradesCsv(input: GenerateTradesCsvInput!): GenerateTradesCsvPayload
  joinTrades(input: JoinTradesInput!): JoinTradesPayload
  processTrade(input: ProcessTradeInput!): ProcessTradePayload
  trackTrade(input: TrackTradeInput!): TrackTradePayload
  updateTradesMarkup(input: UpdateTradesMarkupInput!): UpdateTradesMarkupPayload
  approveWithdrawalTransaction(input: ApproveWithdrawalTransactionInput!): ApproveWithdrawalTransactionPayload
  createTransaction(input: CreateTransactionInput!): CreateTransactionPayload
  generateTransactionsCsv(input: GenerateTransactionsCsvInput!): GenerateTransactionsCsvPayload
  migrateTransactions(input: MigrateTransactionsInput!): MigrateTransactionsPayload
  updateTransaction(input: UpdateTransactionInput!): UpdateTransactionPayload
  createTrigger(input: CreateTriggerInput!): CreateTriggerPayload
  updateTrigger(input: UpdateTriggerInput!): UpdateTriggerPayload
  updateTriggerStatus(input: UpdateTriggerStatusInput!): UpdateTriggerPayload
  claimUserAchievement(input: ClaimUserAchievementInput!): ClaimUserAchievementPayload
  createUserAchievement(input: CreateUserAchievementInput!): CreateUserAchievementPayload
  triggerUserAchievement(input: TriggerUserAchievementInput!): TriggerUserAchievementPayload
  flushUserAchievementCache(input: FlushUserAchievementCacheInput!): FlushUserAchievementCachePayload
  createUserAddress(input: CreateUserAddressInput!): UserAddressPayload!
  deleteUserAddress(input: DeleteUserAddressInput!): UserAddressPayload!
  updateUserAddress(input: UpdateUserAddressInput!): UserAddressPayload!
  setUserAsset(input: SetUserAvatarInput): UserAsset
  purchaseBox(input: PurchaseBoxInput!): PurchaseBoxPayload
  refundUserBox(input: RefundUserBoxInput!): RefundUserBoxPayload
  createUserCommunication(input: CreateUserCommunicationInput!): CreateUserCommunicationPayload
  deleteUserCommunication(input: DeleteUserCommunicationInput!): DeleteUserCommunicationPayload
  generateUserDepositWithdrawalCsv(input: GenerateUserDepositWithdrawalCsvInput!): GenerateUserDepositWithdrawalCsvPayload
  checkUserItemStatus(input: CheckUserItemStatusInput!): CheckUserItemStatusPayload
  updateUserItem(input: UpdateUserItemInput!): UpdateUserItemPayload
  updateUserItemShipTo(input: UpdateUserItemShipToInput!): UpdateUserItemPayload
  updateUserPreferences(input: UpdateUserPreferencesInput!): UpdateUserPreferencesPayload
  purchaseXp(input: PurchaseXpInput!): PurchaseXpPayload!
  claimUserTierAsset(userTierAssetId: ID!): UserAsset
  createUserTierAsset(input: CreateUserTierAssetInput!): UserTierAsset
  deleteUserTierAsset(id: ID!): UserTierAsset
  updateUserTierAsset(input: UpdateUserTierAssetInput!): UserTierAsset
  updateUserTier(input: UpdateUserTierInput!): UserTier
  disableTotpTwoFactorAuthentication(input: DisableTotpTwoFactorAuthenticationInput!): DisableTotpTwoFactorAuthenticationPayload
  enableTotpTwoFactorAuthentication(input: EnableTotpTwoFactorAuthenticationInput!): EnableTotpTwoFactorAuthenticationPayload
  generateNewTotpTwoFactorBackupCodes(input: GenerateNewTotpTwoFactorBackupCodesInput!): GenerateNewTotpTwoFactorBackupCodesPayload!
  generateTotpTwoFactorAuthenticationSecret: GenerateTotpTwoFactorAuthenticationSecretPayload
  invalidateAllUserSessions(input: InvalidateAllUserSessionsInput): InvalidateAllUserSessionsPayload
  login(email: String, password: String): LoginPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  updateUserEmail(input: UpdateUserEmailInput!): UpdateUserEmailPayload
  retrieveTotpTwoFactorBackupCodes(input: RetrieveTotpTwoFactorBackupCodesInput!): RetrieveTotpTwoFactorBackupCodesPayload
  revertUser(input: RevertUserInput!): RevertUserPayload
  acceptTos(input: AcceptTosInput!): AcceptTosPayload
  updateSuspectedTrader(input: UpdateSuspectedTraderInput!): UpdateSuspectedTraderPayload
  sendValidationEmail(input: SendValidationEmailInput!): SendValidationEmailPayload
  verifyEmail(input: VerifyEmailInput!): VerifyEmailPayload
  generateWalletChangesCsv(input: GenerateWalletChangesCsvInput!): GenerateWalletChangesCsvPayload!
  claimAffiliateWallet(input: AffiliateClaimAmountInput!): UpdateWalletPayload
  consolidateWallets(input: ConsolidateWalletsInput!): ConsolidateWalletsPayload
  moveBetweenWallets(input: MoveBetweenWalletsInput!): MoveBetweenWalletsPayload
  updateWallet(input: UpdateWalletInput!): UpdateWalletPayload
  claimAdditionalRewardsWallet(input: AdditionalRewardClaimInput!): AdditionalRewardClaimPayload
  claimRakeback(input: RakebackClaimInput!): RakebackClaimPayload
  createWaxPeerTrade(input: CreateWaxPeerTradeInput!): CreateWaxPeerTradePayload
  trackWaxPeerTrade(input: TrackWaxPeerTradeInput!): TrackWaxPeerTradePayload
  createWishlist(input: CreateWishlistInput!): CreateWishlistPayload
  updateWishlist(input: UpdateWishlistInput!): UpdateWishlistPayload
  createWithdrawalRequest(input: CreateWithdrawalRequestInput!): CreateWithdrawalRequestPayload
  updateWithdrawalRequest(input: UpdateWithdrawalRequestInput!): UpdateWithdrawalRequestPayload
  increaseWithdrawalRequestAmount(input: IncreaseWithdrawalRequestInput!): IncreaseWithdrawalRequestPayload
  cancelZbtTrade(input: CancelZbtTradeInput!): CancelZbtTradePayload
  createZbtTrade(input: CreateZbtTradeInput!): CreateZbtTradePayload
  trackZbtTrade(input: TrackZbtTradeInput!): TrackZbtTradePayload
  abortZincOrder(input: AbortZincOrderInput!): AbortZincOrderPayload
  cancelZincOrder(input: CancelZincOrderInput!): CancelZincOrderPayload
  createZincOrder(input: CreateZincOrderInput!): CreateZincOrderPayload
  retryZincOrder(input: RetryZincOrderInput!): RetryZincOrderPayload
}

input CreateAchievementInput {
  autoClaim: Boolean
  description: String!
  enabled: Boolean!
  imageUrl: String!
  limitPerUser: Int
  name: String!
  rewards: [AchievementRewardInput!]!
  rewardsExpireAfterSeconds: Int!
  trigger: AchievementTriggerInput
  type: AchievementType
}

input UpdateAchievementInput {
  autoClaim: Boolean
  description: String
  enabled: Boolean
  imageUrl: String
  limitPerUser: Int
  name: String
  rewards: [AchievementRewardInput!]!
  rewardsExpireAfterSeconds: Int
  trigger: AchievementTriggerInput
}

input FlushAchievementCacheInput {
  unused: Boolean
}

enum AchievementOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum AchievementType {
  CHAT_MESSAGE
  LOST_WAGER_ON_GAME
  TWITTER_FOLLOWER
  WAGER_ON_GAME
  WON_WAGER_ON_GAME
}

type AffiliateBlogPostResult {
  id: String!
  url: String!
  title: String!
  image: String
  date: SequelizeDate
  tags: [String]
}

type AffiliateBlogPostsPayload {
  posts: [AffiliateBlogPostResult]
}

type AffiliateUrlsPayload {
  urls: [String!]
}

type AffiliateUrlPayload {
  url: String!
}

input AffiliateBlogInput {
  count: Int!
  tags: [String]
}

input AffiliatePromoImageIdentifier {
  id: ID!
}

input AffiliatePromoImageInput {
  file: Upload!
}

type AffiliateLoanRequest implements Node {
  id: ID!
  userId: ID!
  user: User
  acceptedByUserId: ID
  acceptedBy: User
  amount: Float!
  currency: String!
  description: String!
  status: AffiliateLoanStatus!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type AffiliateLoanRequestConnection {
  edges: [AffiliateLoanRequestEdge]
  pageInfo: PageInfo!
  total: Int
}

type AffiliateLoanRequestEdge {
  cursor: String!
  node: AffiliateLoanRequest
}

type CreateLoanRequestPayload {
  affiliateLoanRequest: AffiliateLoanRequest
}

type UpdateLoanRequestPayload {
  affiliateLoanRequest: AffiliateLoanRequest
}

type Subscription {
  createAffiliateLoanRequest: CreateLoanRequestPayload!
  updateAffiliateLoanRequest: UpdateLoanRequestPayload!
  createBet(userId: ID): CreateBetSubscriptionPayload!
  refreshCachedGameBets: RefreshCachedGameBetsSubscriptionPayload!
  createBoxOpening(ancestorBoxId: ID, boxId: ID, boxSlug: String, minItemValue: Float): CreateBoxOpeningSubscriptionPayload!
  createBox: CreateBoxSubscriptionPayload
  updateBox: UpdateBoxSubscriptionPayload
  createCalendarEntry: CreateCalendarEntrySubscriptionPayload
  createCalendar: CreateCalendarSubscriptionPayload
  updateCalendar: UpdateCalendarSubscriptionPayload
  deleteCalendar: DeleteCalendarSubscriptionPayload
  updateCasinoGame: UpdateCasinoGameSubscriptionPayload!
  createCrashBet: CreateCrashBetSubscriptionPayload!
  updateCrashBet(id: ID): UpdateCrashBetSubscriptionPayload!
  createCrashGame: CreateCrashGameSubscriptionPayload
  updateCrashGame: UpdateCrashGameSubscriptionPayload
  createDiceBets: CreateDiceBetsSubscriptionPayload!
  createDigitalCode: CreateDigitalCodeSubscriptionPayload!
  updateDigitalCode: UpdateDigitalCodeSubscriptionPayload!
  deleteDigitalCode: DeleteDigitalCodeSubscriptionPayload!
  createDocument: CreateDocumentSubscriptionPayload
  deleteDocument: DeleteDocumentSubscriptionPayload
  createDropCacheItem: DropAddedRequestSubscriptionPayload!
  createGameJackpot: CreateGameJackpotSubscriptionPayload!
  updateGameJackpot(id: ID): UpdateGameJackpotSubscriptionPayload!
  createGameMessage(gameId: ID): CreateGameMessageSubscriptionPayload!
  createPvpGameMessage(pvpGameId: ID): CreatePvpGameMessageSubscriptionPayload!
  createGame: CreateGameSubscriptionPayload!
  refreshCachedLatestGames: RefreshCachedLatestGamesSubscriptionPayload!
  updateGame: UpdateGameSubscriptionPayload!
  createGemstoneBoostActivation: CreateGemstoneBoostActivationPayload!
  updateGemstoneBoostInfo: UpdateGemstoneBoostSubscriptionPayload
  winGemstones: WinGemstoneSubscription!
  createGiveaway: CreateGiveawayPayload!
  updateGiveaway: UpdateGiveawayPayload!
  createItemCategory: CreateItemCategorySubscriptionPayload!
  updateItemCategory: UpdateItemCategorySubscriptionPayload!
  deleteItemCategory: DeleteItemCategorySubscriptionPayload!
  createItemVariant: CreateItemVariantSubscriptionPayload!
  updateItemVariant: UpdateItemVariantSubscriptionPayload!
  deleteItemVariant: DeleteItemVariantSubscriptionPayload!
  createItem: CreateItemSubscriptionPayload!
  updateItem: UpdateItemSubscriptionPayload!
  createJackpotWinningTicket: JackpotWinningTicketSubscriptionPayload!
  createJackpot: CreateJackpotSubscriptionPayload!
  updateJackpot(id: ID): UpdateJackpotSubscriptionPayload!
  createMatchBettingGame: CreateMatchBettingGameSubscriptionPayload!
  updateMatchBettingGame: UpdateMatchBettingGameSubscriptionPayload!
  createMatchBettingLeague: CreateMatchBettingLeagueSubscriptionPayload!
  updateMatchBettingLeague: UpdateMatchBettingLeagueSubscriptionPayload!
  createMatchBettingMarket(matchIds: [ID!], statuses: [MatchBettingMarketStatus!], videoGames: [MatchBettingVideoGame!]): CreateMatchBettingMarketSubscriptionPayload!
  matchBettingMarketOddsUpdate(marketIds: [ID!], matchIds: [ID!], statuses: [MatchBettingMarketStatus!], videoGames: [MatchBettingVideoGame!]): MatchBettingMarketOddsUpdatePayload!
  updateMatchBettingMarket(marketIds: [ID!], matchIds: [ID!], statuses: [MatchBettingMarketStatus!], videoGames: [MatchBettingVideoGame!]): UpdateMatchBettingMarketSubscriptionPayload!
  createMatchBettingMatch(name: String, statuses: [MatchBettingMatchStatus!], videoGame: MatchBettingVideoGame): CreateMatchBettingMatchSubscriptionPayload!
  updateMatchBettingMatch(id: ID, name: String, statuses: [MatchBettingMatchStatus!], videoGame: MatchBettingVideoGame): UpdateMatchBettingMatchSubscriptionPayload!
  createMatchBettingPlayer: CreateMatchBettingPlayerSubscriptionPayload!
  updateMatchBettingPlayer: UpdateMatchBettingPlayerSubscriptionPayload!
  createMatchBettingSerie: CreateMatchBettingSerieSubscriptionPayload!
  updateMatchBettingSerie: UpdateMatchBettingSerieSubscriptionPayload!
  createMatchBettingSlip(statuses: [MatchBettingSlipStatus!], userId: ID): CreateMatchBettingSlipSubscriptionPayload!
  updateMatchBettingSlip(id: ID, statuses: [MatchBettingSlipStatus!], userId: ID): UpdateMatchBettingSlipSubscriptionPayload!
  createMatchBettingTeam: CreateMatchBettingTeamSubscriptionPayload!
  updateMatchBettingTeam: UpdateMatchBettingTeamSubscriptionPayload!
  createMatchBettingTournament: CreateMatchBettingTournamentSubscriptionPayload!
  updateMatchBettingTournament: UpdateMatchBettingTournamentSubscriptionPayload!
  matchBettingUpdateHeartBeat: MatchBettingUpdateHeartBeatSubscriptionPayload!
  createMessage(channel: String!): CreateMessageSubscriptionPayload!
  deleteMessage(channel: String!): DeleteMessageSubscriptionPayload!
  createNotificationMessage: CreateNotificationMessageSubscriptionPayload!
  updateNotificationMessage: UpdateNotificationMessageSubscriptionPayload!
  createNotification: CreateNotificationSubscriptionPayload!
  updateNotification: UpdateNotificationSubscriptionPayload!
  createOrder: CreateOrderSubscriptionPayload!
  updateOrder: UpdateOrderSubscriptionPayload!
  deleteOrder: DeleteOrderSubscriptionPayload!
  createPlinkoBet: CreatePlinkoBetSubscriptionPayload!
  plinkoBetSlotsChanged: PlinkoBetSlotsPayload!
  updatePollOption: UpdatePollOptionPayload!
  createPoll: CreatePollPayload!
  deletePoll: DeletePollSubscriptionPayload
  updatePoll: UpdatePollPayload!
  updatePollStatus: UpdatePollStatusPayload!
  createPromoCode: CreatePromoCodeSubscriptionPayload!
  deletePromoCode: DeletePromoCodeSubscriptionPayload!
  updatePromoCode(code: String!, marketId: ID!): UpdatePromoCodeSubscriptionPayload!
  usedPromoCode: UsedPromoCodeSubscriptionPayload!
  createPvpBet: CreatePvpBetSubscriptionPayload!
  updatePvpBet: UpdatePvpBetSubscriptionPayload!
  createPvpBot: CreatePvpBotSubscriptionPayload!
  updatePvpBot: UpdatePvpBetSubscriptionPayload!
  createPvpGame: CreatePvpGameSubscriptionPayload!
  playPvpGame: PlayPvpGameSubscriptionPayload!
  updatePvpGame(id: ID, userId: ID): UpdatePvpGameSubscriptionPayload!
  createPvpRound(pvpGameId: ID): CreatePvpRoundSubscriptionPayload!
  updatePvpRound(id: ID, pvpGameId: ID): UpdatePvpRoundSubscriptionPayload!
  createRoll: CreateRollSubscriptionPayload!
  onlineCount: Int
  updateSetting: UpdateSettingSubscriptionPayload!
  flushSettingCache: String
  createSteamAsset: CreateSteamAssetSubscriptionPayload!
  updateSteamAsset(id: ID): UpdateSteamAssetSubscriptionPayload!
  deleteSteamAsset: DeleteSteamAssetSubscriptionPayload!
  createSteamBot: CreateSteamBotSubscriptionPayload!
  updateSteamBot: UpdateSteamBotSubscriptionPayload!
  deleteSteamBot: DeleteSteamBotSubscriptionPayload!
  createSteamOffer: CreateSteamOfferSubscriptionPayload
  updateSteamOffer(id: ID): UpdateSteamOfferSubscriptionPayload
  deleteSteamOffer: DeleteSteamOfferSubscriptionPayload
  createTag: CreateTagSubscriptionPayload!
  updateTag: UpdateTagSubscriptionPayload!
  deleteTag: DeleteTagSubscriptionPayload!
  createTicket(userId: ID): CreateTicketSubscriptionPayload!
  createTrade(userId: ID): CreateTradeSubscriptionPayload!
  updateTrade(status: TradeStatus, userId: ID): UpdateTradeSubscriptionPayload!
  removeFromListedTrade: RemoveFromListedTradeSubscriptionPayload!
  createTransaction: CreateTransactionSubscriptionPayload!
  updateTransaction(id: ID): UpdateTransactionSubscriptionPayload!
  createTrigger: CreateTriggerPayload!
  updateTrigger: UpdateTriggerPayload!
  updateTriggerStatus: UpdateTriggerPayload!
  createUserAchievement(userId: ID): CreateUserAchievementSubscriptionPayload!
  updateUserAchievement: UpdateUserAchievementSubscriptionPayload!
  createUserAsset: CreateUserAssetSubscriptionPayload!
  createUserBox: CreateUserBoxSubscriptionPayload!
  updateUserBox: UpdateUserBoxSubscriptionPayload!
  createUserCommunication: CreateUserCommunicationSubscriptionPayload!
  deleteUserCommunication: DeleteUserCommunicationSubscriptionPayload!
  createUserGiveaway: CreateUserGiveawayPayload!
  updateUserGiveaway: UpdateUserGiveawayPayload!
  createUserItem: CreateUserItemSubscriptionPayload!
  updateUserItem: UpdateUserItemSubscriptionPayload!
  deleteUserItem: DeleteUserItemSubscriptionPayload!
  createUserPollOptions(pollId: ID, userId: ID): CreateUserPollOptionsPayload
  updateUserProgress: UpdateUserProgressSubscriptionPayload
  claimUserTierAsset: ClaimUserTierAssetSubscriptionPayload!
  createUserTierAsset: CreateUserTierAssetSubscriptionPayload!
  deleteUserTierAsset: DeleteUserTierAssetSubscriptionPayload!
  updateUserTierAsset: UpdateUserTierAssetSubscriptionPayload!
  createUser: CreateUserSubscriptionPayload!
  updateUser: UpdateUserSubscriptionPayload!
  authenticatedUser: AuthenticatedUserSubscriptionPayload!
  updateWallet(walletType: [WalletType!]): UpdateWalletSubscriptionPayload!
  createWaxPeerTrade: CreateWaxPeerTradeSubscriptionPayload!
  updateWaxPeerTrade: UpdateWaxPeerTradeSubscriptionPayload!
  createWishlist: CreateWishlistPayload!
  updateWishlist: CreateWishlistPayload!
  createWithdrawalRequest: CreateWithdrawalRequestSubscriptionPayload!
  updateWithdrawalRequest: UpdateWithdrawalRequestSubscriptionPayload!
  createZbtTrade: CreateZbtTradeSubscriptionPayload!
  updateZbtTrade: UpdateZbtTradeSubscriptionPayload!
  createZincOrder: CreateZincOrderSubscriptionPayload!
  updateZincOrder: UpdateZincOrderSubscriptionPayload!
  deleteZincOrder: DeleteZincOrderSubscriptionPayload!
}

input AffiliateLoanRequestArgs {
  acceptedByUserId: ID
  amount: Float
  createdAt: SequelizeDate
  currency: String
  description: String
  limit: Int
  offset: Int
  orderBy: [AffiliateLoanRequestOrderBy]
  page: Int
  status: AffiliateLoanStatus
  userId: ID
}

input AffiliateLoanResponseToInput {
  id: ID!
  status: AffiliateLoanStatus!
}

input AffiliateLoanCancelInput {
  id: ID!
}

input AffiliateLoanRequestInput {
  amount: Int!
  currency: String!
  description: String!
}

enum AffiliateLoanStatus {
  ACCEPTED
  CANCELLED
  REJECTED
  WAITING
}

enum AffiliateLoanRequestOrderBy {
  ACCEPTED_BY_USER_ID
  ACCEPTED_BY_USER_ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DESCRIPTION
  DESCRIPTION_DESC
  ID
  ID_DESC
  STATUS
  STATUS_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  USER_ID
  USER_ID_DESC
}

type AffiliateUserSummary {
  avatar: String
  displayName: String
  xp: String
}

type Tracker {
  count: Int!
  date: SequelizeDate
  index: Int
}

type TrackerTimeSeries {
  status: UserAffiliateStatus!
  timeSeries: [Tracker]!
}

type RefereeActivityResult {
  active: TrackerTimeSeries!
  stealable: TrackerTimeSeries!
  retargetable: TrackerTimeSeries!
  unconverted: TrackerTimeSeries!
}

type AffiliateAllTime {
  affiliateUserId: ID
  avatar: String
  commission: Float
  deposited: Float
  displayName: String
  hideSteamProfile: Boolean
  lastActiveAt: SequelizeDate
  lastDepositAt: SequelizeDate
  level: Int
  rank: Int
  refereeId: ID
  status: UserAffiliateStatus
  url: String
  wageredTotal: Float
}

type AffiliateAllTimeResult {
  edges: [AffiliateAllTimeEdge]
  pageInfo: PageInfo!
  pages: [String]
  total: Int
}

type AffiliateAllTimeEdge {
  cursor: String
  node: AffiliateAllTime
}

type AffiliateEarningsResult {
  commission: Float
  date: SequelizeDate
  deposited: Float
  wageredBoxOpen: Float
  wageredCrash: Float
  wageredDice: Float
  wageredPlinko: Float
  wageredRoulette: Float
  wageredPvp: Float
  wageredMatchBetting: Float
  wageredTotal: Float
}

type TotalCommisionGivenAwayPayload {
  amount: Float!
}

type RefereeDailyActivityResult {
  timeSeries: [Tracker!]!
}

type AffiliateStatusCountResult {
  affiliateUserId: ID!
  active: Int!
  stealable: Int!
  retargetable: Int!
  total: Int!
  totalAllTime: Int!
  unconverted: Int!
}

type CreateAffiliateReportsJobPayload {
  status: Boolean
}

type AffiliateActiveCountResult {
  count: Int!
}

type RefereeStatusResult {
  status: UserAffiliateStatus
  secondsLeft: Int
}

type AffiliateRanJobsByDay {
  day: String!
}

enum AffiliateReportJobType {
  AFFILIATE_REPORT
  AFFILIATE_REPORT_COMMISSION_ACTIVITY
  AFFILIATE_REPORT_DEPOSIT_ACTIVITY
  AFFILIATE_REPORT_SEARCH
}

input AffiliateUserIdentifier {
  affiliateUserId: ID!
}

input AffiliateReportJobInput {
  jobTypes: [AffiliateReportJobType!]
  secret: String
  startDate: SequelizeDate
}

input RefereeStatusInput {
  id: ID!
}

input RefereeActivityInput {
  affiliateUserId: ID!
  dateRange: AffiliateReportType
  endDate: SequelizeDate
  startDate: SequelizeDate
}

input AffiliateAllTimeInput {
  affiliateUserId: ID!
  after: String
  before: String
  first: PaginationAmount
  last: PaginationAmount
  limit: PaginationAmount
  orderBy: [AffiliateReportAllTimeOrderBy]
  page: Int
  status: UserAffiliateStatus
}

input AffiliateEarningsInput {
  affiliateUserId: ID!
  startDate: SequelizeDate
  endDate: SequelizeDate
}

input AffiliateStatusCountsInput {
  affiliateUserId: ID!
  endDate: SequelizeDate
  startDate: SequelizeDate
}

input RefereeDailyActivityInput {
  affiliateUserId: ID!
  dateRange: AffiliateReportType
  endDate: SequelizeDate
  startDate: SequelizeDate
}

input AffiliateActiveCountInput {
  affiliateUserId: ID
  endDate: SequelizeDate
  startDate: SequelizeDate
}

input AffiliateSecretInput {
  secret: String!
}

enum UserAffiliateStatus {
  ACTIVE
  STEALABLE
  RETARGETABLE
  STOLEN
  UNCONVERTED
}

enum AffiliateReportType {
  DAILY
  MONTHLY
  WEEKLY
  YEARLY
}

enum AffiliateReportAllTimeOrderBy {
  AFFILIATE_STATUS @deprecated(reason: "Use LAST_DEPOSIT_DAY")
  AFFILIATE_STATUS_DESC @deprecated(reason: "Use LAST_DEPOSIT_DAY_DESC")
  COMMISSION
  COMMISSION_DESC
  DEPOSIT
  DEPOSIT_DESC
  DISPLAY_NAME
  DISPLAY_NAME_DESC
  LAST_ACTIVE_AT
  LAST_ACTIVE_AT_DESC
  LAST_DEPOSIT_DAY
  LAST_DEPOSIT_DAY_DESC
  WAGERED_TOTAL
  WAGERED_TOTAL_DESC
}

type AffiliateSearch implements Node {
  affiliateTier: AffiliateTier
  affiliateTierId: ID
  affiliateUser: User
  affiliateUserId: ID
  avatar: String
  displayName: String
  id: ID!
  lastActiveAt: SequelizeDate
  market: Market
  marketId: ID
  totalCommissionEarnt: Float
  totalDepositOfReferredUsers: Float
  totalDepositorsReferred: Int
  totalUsersReferred: Int
  totalWithdrawOfReferredUsers: Float
  xp: BigInt
}

type AffiliateSearchEdge {
  cursor: String!
  node: AffiliateSearch
}

type AffiliateSearchConnection {
  edges: [AffiliateSearchEdge]
  pageInfo: PageInfo!
  pages: [String]
  total: Int
}

input AffiliateSearchInputs {
  affiliateCode: String
  affiliateTierId: Int
  after: String
  before: String
  displayName: String
  first: Int
  fuzzy: Float
  id: ID
  last: Int
  lastActiveAt: SequelizeDate
  limit: Int
  marketId: Int
  orderBy: [AffiliateSearchOrderBy]
  page: Int
  totalCommissionEarnt: Float
  totalDepositOfReferredUsers: Float
  totalDepositorsReferred: Int
  totalUsersReferred: Int
  totalWithdrawOfReferredUsers: Float
}

enum AffiliateSearchOrderBy {
  COMMISSION
  COMMISSION_DESC
  DISPLAY_NAME
  DISPLAY_NAME_DESC
  ID
  ID_DESC
  LAST_ACTIVE_AT
  LAST_ACTIVE_AT_DESC
  MARKET
  MARKET_DESC
  TIER
  TIER_DESC
  TOTAL_DEPOSIT
  TOTAL_DEPOSIT_DESC
  TOTAL_DEPOSIT_USERS
  TOTAL_DEPOSIT_USERS_DESC
  TOTAL_USERS
  TOTAL_USERS_DESC
  TOTAL_WITHDRAW
  TOTAL_WITHDRAW_DESC
}

type AffiliateTier implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  name: String!
  canClaimItems: Boolean!
  commissionRequirement: Float
  depositRequirement: Float!
  stickyReferees: Boolean!
  commissionPercentage: Float!
  roulettePercentage: Float!
  unboxingPercentage: Float!
  crashPercentage: Float!
  dicePercentage: Float!
  pvpPercentage: Float!
  matchBettingPercentage: Float!
  plinkoPercentage: Float!
  depositPercentage: Float!
  loanLimit: Int
  promoCodeLimit: Int
  minimumReferralsClaimRequirement: Int
  minimumActiveReferralsClaimRequirement: Int
  ancestorAffiliateTierId: ID!
}

type AffiliateTierConnection {
  pageInfo: PageInfo!
  edges: [AffiliateTierEdge]
  total: Int
}

type AffiliateTierEdge {
  node: AffiliateTier
  cursor: String!
}

type AffiliateTierPayload {
  affiliateTier: AffiliateTier!
}

input CreateAffiliateTierInput {
  ancestorAffiliateTierId: ID!
  canClaimItems: Boolean!
  commissionPercentage: Float!
  commissionRequirement: Float
  crashPercentage: Float!
  depositPercentage: Float!
  depositRequirement: Float!
  dicePercentage: Float!
  inviteCodeLimit: Int!
  loanLimit: Int
  matchBettingPercentage: Float!
  minimumActiveReferralsClaimRequirement: Int
  minimumReferralsClaimRequirement: Int
  name: String!
  plinkoPercentage: Float!
  promoCodeLimit: Int!
  pvpPercentage: Float!
  roulettePercentage: Float!
  stickyReferees: Boolean!
  unboxingPercentage: Float!
}

input DeleteAffiliateTierInput {
  affiliateTierId: ID!
}

input UpdateAffiliateTierInput {
  affiliateTierId: ID!
  ancestorAffiliateTierId: ID
  canClaimItems: Boolean
  commissionPercentage: Float
  commissionRequirement: Float
  crashPercentage: Float
  depositPercentage: Float
  depositRequirement: Float
  dicePercentage: Float
  inviteCodeLimit: Int
  loanLimit: Int
  matchBettingPercentage: Float
  minimumActiveReferralsClaimRequirement: Int
  minimumReferralsClaimRequirement: Int
  name: String
  plinkoPercentage: Float
  promoCodeLimit: Int
  pvpPercentage: Float
  roulettePercentage: Float
  stickyReferees: Boolean
  unboxingPercentage: Float
}

enum AffiliateTierOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  COMMISSION_REQUIREMENT
  COMMISSION_REQUIREMENT_DESC
}

type Asset implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  url: String!
  mimeType: String!
  fileName: String!
  fileSize: String!
  width: String
  height: String
}

type AssetConnection {
  pageInfo: PageInfo!
  edges: [AssetEdge]
  total: Int
}

type AssetEdge {
  node: Asset
  cursor: String!
}

input CreateAssetInput {
  dataUpload: Upload
  fileName: String!
  folder: String!
  height: Int
  isPublic: Boolean!
  mimeType: String!
  url: String
  width: Int
}

enum AssetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type AuditLogMeta {
  currency: String
  matchBettingSlipStatus: MatchBettingSlipStatus
  transactionStatusNew: TransactionStatus
  transactionStatusOld: TransactionStatus
  userBannedUntil: SequelizeDate
  userMutedUntil: SequelizeDate
  walletChangeAmount: Float
  walletChangeType: WalletChangeType
}

type AuditLog implements Node {
  id: ID!
  user: User!
  userId: ID!
  action: AuditLogAction!
  externalId: Int
  externalModel: String
  meta: AuditLogMeta
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type AuditLogConnection {
  pageInfo: PageInfo!
  edges: [AuditLogEdge]
  total: Int
}

type AuditLogEdge {
  node: AuditLog
  cursor: String!
}

enum AuditLogOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum AuditLogAction {
  MATCH_BETTING_SLIP_UPDATED
  OTHER
  TRANSACTION_UPDATED
  USER_BANNED
  USER_MUTED
  WALLET_UPDATED
}

type AvailableAsset {
  steamAssetId: ID!
  steamAsset: SteamAsset
  availableAt: SequelizeDate
}

type Bet implements Node {
  id: ID!
  selection: Int
  selections: [Int!]
  mode: BetMode
  amount: Float!
  payout: Float
  payoutMultiplier: Float
  currency: String!
  gameId: ID
  game: Game
  userId: ID
  user: User
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  type: BetType!
  processed: Boolean!
  rollValue: Int
  gameProviderFeePercent: Float
  affiliateUserId: ID
  rakeback: Float
  ticketsWon: Int!
}

type BetConnection {
  pageInfo: PageInfo!
  edges: [BetEdge]
  total: Int
}

type BetEdge {
  node: Bet
  cursor: String!
}

type CreateBetPayload {
  bet: Bet!
}

type RefreshCachedGameBetsPayload {
  success: Boolean!
}

type CreateBetSubscriptionPayload {
  bet: Bet!
}

type RefreshCachedGameBetsSubscriptionPayload {
  gameId: ID!
  success: Boolean
}

input CreateBetInput {
  amount: Float!
  gameId: ID!
  mode: BetMode
  selection: Int
  selections: [Int!]
}

input RefreshCachedGameBetsInput {
  gameId: ID!
  secret: String
}

enum BetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  AMOUNT
  AMOUNT_DESC
}

enum BetMode {
  NORMAL
  CRAZY
}

enum BetType {
  LEGACY
  MODERN
}

type BoxOpeningMeta {
  userIsPvpBot: Boolean
  xpRewarded: BigInt
}

type BoxOpening implements Node {
  id: ID!
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
  deletedAt: SequelizeDate
  boxValue: Float!
  itemValue: Float!
  profit: Float!
  currency: String!
  boxId: ID!
  itemVariantId: ID
  userItemId: ID
  userId: ID!
  rollId: ID!
  userBoxId: ID!
  boxItemId: ID!
  box: Box
  itemVariant: ItemVariant
  userItem: UserItem
  user: User
  roll: Roll
  userBox: UserBox
  ticketsWon: Int!
  pvpGame: PvpGame
  pvpGameId: ID
  pvpBet: PvpBet
  pvpBetId: ID
  lostToUser: User
  lostToUserId: ID
  meta: BoxOpeningMeta
  pfVersion: ProvablyFairVersion!
  wonUserBox: UserBox
  wonUserBoxId: ID
  wonBox: Box
  wonBoxId: ID
  balance: Float
  wonMultiplier: Float
  gameProviderFeePercent: Float
  affiliateUserId: ID
  rakeback: Float
  wonGemstones: Float
  wonJackpotTickets: Int
  wonXp: Int
}

type BoxOpeningConnection {
  pageInfo: PageInfo!
  edges: [BoxOpeningEdge]
  total: Int
}

type BoxOpeningEdge {
  node: BoxOpening
  cursor: String!
}

type BoxStat {
  openCount: Int
  profit: Float
  averageProfit: Float
  itemValue: Float
  totalAcquiredValue: Float
  totalConsumedValue: Float
  totalOrderCost: Float @deprecated(reason: "Too heavy and not valuable enough right now")
  box: Box
}

type BoxItemVariantStat {
  obtained: Int
  consumed: Int
  exchanged: Int
  requested: Int
  processing: Int
  ordered: Int
  available: Int
  itemVariant: ItemVariant
  orderCost: Float
}

type CreateBoxOpeningPayload {
  box: Box
  boxOpenings: [BoxOpening]
}

type CreateBoxOpeningSubscriptionPayload {
  boxOpening: BoxOpening!
}

type LuckiestBoxOpening {
  boxOpening: BoxOpening
  totalOpenings: Int!
}

type RefreshBoxOpeningStream {
  boxOpeningsByTime: [BoxOpening!]!
  boxOpeningsByValue: [BoxOpening!]!
}

type AddRefreshBoxOpeningStreamTasks {
  success: Boolean!
}

input CreateBoxOpeningItemInput {
  id: ID!
  rate: Float!
}

input OpenBoxInput {
  boxId: ID!
  amount: Int
  multiplierBoxBet: Float
}

input AddRefreshBoxOpeningStreamTasksInput {
  refreshForCache: [AddRefreshBoxOpeningStreamTasksForCache!]!
}

input RefreshBoxOpeningStreamInput {
  ancestorBoxId: ID
  boxSlug: String
  secret: String
}

enum BoxOpeningOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  ITEM_VALUE
  ITEM_VALUE_DESC
  BOX_VALUE
  BOX_VALUE_DESC
}

enum AddRefreshBoxOpeningStreamTasksForCache {
  ALL_BOXES
  ANCESTOR_BOX_ID
  BOX_SLUG
}

type Box implements Node {
  id: ID!
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
  deletedAt: SequelizeDate
  enabled: Boolean
  levelRequired: Int!
  free: Boolean
  isFavorite: Boolean
  purchasable: Boolean
  openable: Boolean
  sellable: Boolean
  giveJackpotTicket: Boolean
  ticketsRewarded: Int!
  order: Int
  type: BoxType
  name: String
  slug: String
  description: String
  iconUrl: String
  price: Float
  priceFixed: Float
  expectedValue: Float
  houseEdgePercent: Float
  maxExpectedValue: Float
  maxPurchasesDaily: Int
  availableFrom: SequelizeDate
  availableUntil: SequelizeDate
  walletRestrictions: [WalletType]
  calculatedPrice: Float
  calculatedExpectedValue: Float
  cost: Float
  currency: String!
  creatorId: ID
  unopenedUserBoxesCount: Int
  creator: User
  ancestorBoxId: ID!
  marketId: ID!
  market: Market
  ancestorBox: Box
  tags: [Tag]
  slots(multiplierBoxBet: Float): [BoxSlot!]!
  totalBoxOpenings: Int!
  totalSpent: Float
  totalProfit: Float
  averageProfit: Float
  totalUnboxedValue: Float
  backgroundImageUrl: String
  discountPrice: Float
  discountPercent: Float!
  originalPrice: Float!
  userLastPurchasedAt: SequelizeDate
  pfVersion: ProvablyFairVersion!
  slotType: BoxSlotType!
}

type BoxConnection {
  pageInfo: PageInfo!
  edges: [BoxEdge]
  total: Int
}

type BoxEdge {
  node: Box
  cursor: String!
}

type CreateBoxPayload {
  box: Box!
}

type ToggleFavoriteBoxPayload {
  status: ToggleFavoriteBoxStatus!
}

type UpdateBoxPayload {
  box: Box!
}

type CreateBoxSubscriptionPayload {
  box: Box!
}

type UpdateBoxSubscriptionPayload {
  box: Box!
}

type RefreshBoxesPayload {
  success: Boolean!
}

type UpdateBoxOrderPayload {
  success: Boolean!
}

type FavouriteBox {
  box: Box
  totalOpenings: Int!
}

type RecalculateBoxStatisticsPayload {
  success: Boolean!
}

type BoxSlot {
  box: Box
  boxId: ID
  gemstones: Float
  id: ID!
  imageUrl: String
  item: Item
  itemId: ID
  itemVariant: ItemVariant
  jackpotTickets: Int
  balance: Float
  rate: Float
  rollEnd: Float
  rollStart: Float
  multiplier: Float
  multiplierType: BoxSlotMultiplierType
  xp: Int
}

type GenerateBoxesCsvPayload {
  fileName: String!
}

input BoxSlotInput {
  boxId: ID
  gemstones: Float
  imageUrl: String
  itemId: ID
  jackpotTickets: Int
  multiplier: Float
  multiplierType: BoxSlotMultiplierType
  rate: Float!
  xp: Int
}

input CreateBoxInput {
  description: String!
  discountPrice: Float
  enabled: Boolean!
  iconUrl: String!
  slots: [BoxSlotInput]!
  levelRequired: Int
  marketId: ID
  maxExpectedValue: Float
  maxPurchasesDaily: Int
  name: String!
  openable: Boolean
  order: Int
  houseEdgePercent: Float
  priceFixed: Float
  purchasable: Boolean
  sellable: Boolean
  ticketsRewarded: Int
  tags: [String]
  type: BoxType!
  availableFrom: SequelizeDate
  availableUntil: SequelizeDate
  backgroundImageUrl: String
  walletRestrictions: [WalletType]
}

input ToggleFavoriteBoxInput {
  boxId: ID!
}

input UpdateBoxInput {
  description: String
  discountPrice: Float
  enabled: Boolean
  iconUrl: String
  id: ID!
  slots: [BoxSlotInput]
  levelRequired: Int
  marketId: ID
  maxExpectedValue: Float
  maxPurchasesDaily: Int
  houseEdgePercent: Float
  name: String
  openable: Boolean
  order: Int
  priceFixed: Float
  purchasable: Boolean
  sellable: Boolean
  ticketsRewarded: Int
  tags: [String]
  type: BoxType
  availableFrom: SequelizeDate
  availableUntil: SequelizeDate
  backgroundImageUrl: String
  walletRestrictions: [WalletType]
}

input UpdateBoxOrderInput {
  boxes: [BoxOrderItem!]!
}

input BoxOrderItem {
  id: ID!
  order: Int!
}

input RefreshBoxesInput {
  boxIds: [ID!]
  forceClone: Boolean
  marketId: ID
}

input RecalculateBoxStatisticsInput {
  secret: String
}

input GenerateBoxesCsvInput {
  after: String
  first: PaginationAmount
  before: String
  last: PaginationAmount
  orderBy: [BoxOrderBy]
  isFavorite: Boolean
  itemId: ID
  tags: [String]
  excludeTags: [String]
  name: String
  boxName: String
  itemName: String
  minLevelRequired: Int
  free: Boolean
  availableFrom: SequelizeDate
  availableUntil: SequelizeDate
  statsProcessedAt: SequelizeDate
  minValue: Float
  maxValue: Float
  type: BoxType
  walletRestrictions: [WalletType]
  enabled: Boolean
  purchasable: Boolean
  openable: Boolean
  sellable: Boolean
  ancestorBoxId: ID
  marketId: ID
  marketSlug: String
  itemIds: [ID!]
  minCost: Float
  maxCost: Float
  discounted: Boolean
  dailyLimited: Boolean
  slotTypes: [BoxSlotType!]
}

enum BoxOrderBy {
  ID
  ID_DESC
  VALUE
  CREATED_AT
  ORDER
  CREATED_AT_DESC
  CREATED_AT_ASC
  UPDATED_AT_DESC
  UPDATED_AT_ASC
  VALUE_ASC
  VALUE_DESC
  ORDER_ASC
  ORDER_DESC
  ANCESTOR_BOX_ID
  ANCESTOR_BOX_ID_DESC
  MIN_LEVEL_REQUIRED
  MIN_LEVEL_REQUIRED_DESC
  TOTAL_BOX_OPENINGS
  TOTAL_BOX_OPENINGS_DESC
  TOTAL_SPENT
  TOTAL_SPENT_DESC
  COST_ASC
  COST_DESC
  ANCESTOR_TOTAL_BOX_OPENINGS
  ANCESTOR_TOTAL_BOX_OPENINGS_DESC
  ANCESTOR_TOTAL_SPENT
  ANCESTOR_TOTAL_SPENT_DESC
}

enum BoxType {
  OFFICIAL
  CUSTOM
}

enum BoxSlotType {
  REGULAR
  MULTIPLIER
}

enum BoxSlotMultiplierType {
  BALANCE
  ITEM_VARIANT
}

enum ToggleFavoriteBoxStatus {
  ADDED
  ERROR
  REMOVED
}

type CalendarEntry implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  calendarId: ID!
  calendar: Calendar!
  userId: ID!
  user: User!
  rewardCount: Int!
}

type CalendarEntryConnection {
  pageInfo: PageInfo!
  edges: [CalendarEntryEdge]
  total: Int
}

type CalendarEntryEdge {
  node: CalendarEntry
  cursor: String!
}

type CreateCalendarEntryPayload {
  calendarEntry: CalendarEntry!
}

type CreateCalendarEntrySubscriptionPayload {
  calendarEntry: CalendarEntry!
}

input CreateCalendarEntryInput {
  calendarId: ID!
  recaptcha: String!
  visualRecaptcha: String
}

enum CalendarEntryOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type CalendarReward {
  chance: Float!
  lastDeposit: Duration
  minAmount: Int!
  maxAmount: Int!
  level: Int
}

type Calendar implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  creatorId: ID!
  creator: User!
  dailyOpenCount: Int!
  name: String!
  startAt: SequelizeDate!
  endAt: SequelizeDate!
  entries: CalendarEntryConnection!
  rewards: [CalendarReward!]!
}

type CalendarConnection {
  pageInfo: PageInfo!
  edges: [CalendarEdge]
  total: Int
}

type CalendarEdge {
  node: Calendar
  cursor: String!
}

type CreateCalendarPayload {
  calendar: Calendar!
}

type UpdateCalendarPayload {
  calendar: Calendar!
}

type DeleteCalendarPayload {
  calendar: Calendar!
}

type CreateCalendarSubscriptionPayload {
  calendar: Calendar!
}

type DeleteCalendarSubscriptionPayload {
  calendar: Calendar!
}

type UpdateCalendarSubscriptionPayload {
  calendar: Calendar!
}

input CalendarRewardInput {
  chance: Float!
  lastDeposit: Duration
  maxAmount: Int!
  minAmount: Int!
  level: Int
}

input CreateCalendarInput {
  dailyOpenCount: Int
  endAt: SequelizeDate!
  name: String!
  rewards: [CalendarRewardInput!]!
  startAt: SequelizeDate!
}

input DeleteCalendarInput {
  id: ID!
}

input UpdateCalendarInput {
  dailyOpenCount: Int
  endAt: SequelizeDate
  id: ID!
  name: String
  rewards: [CalendarRewardInput!]
  startAt: SequelizeDate
}

enum CalendarOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type CasinoGameAction implements Node {
  id: ID!
  amount: Float
  baseAmount: Float
  userCurrencyAmount: Float
  excluded: Boolean!
  currency: String!
  baseCurrency: String!
  baseCurrencyRate: Float
  userCurrency: String!
  rollbackActionId: ID
  rollbackAction: CasinoGameAction
  externalRollbackActionId: ID
  casinoGameSessionId: ID!
  casinoGameSession: CasinoGameSession
  casinoGameRoundId: ID!
  casinoGameRound: CasinoGameRound
  type: CasinoGameActionType!
  externalActionId: ID!
  jackpotWin: Float
  jackpotContribution: Float
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
}

type CasinoGameActionConnection {
  pageInfo: PageInfo!
  edges: [CasinoGameActionEdge]
  total: Int
}

type CasinoGameActionEdge {
  node: CasinoGameAction
  cursor: String!
}

enum CasinoGameActionType {
  BET
  ROLLBACK
  WIN
}

type CasinoGameLobbyPositionedGame {
  casinoGame: CasinoGame!
  casinoGameId: ID!
  index: Int!
}

type CasinoGameLobby implements Node {
  casinoGames(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [CasinoGameOrderBy], categories: [CasinoGameCategory], enabled: Boolean, isLive: Boolean, slug: String, studios: [CasinoGameProviderCode], title: String): CasinoGameConnection!
  casinoGameProviderTotalGames(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [CasinoGameOrderBy], partialSearch: String, providers: [CasinoGameProviderCode]): [CasinoGameProviderTotalGamesPayload]
  createdAt: SequelizeDate!
  id: ID!
  name: String!
  order: Int
  positionedCasinoGames: [CasinoGameLobbyPositionedGame!]
  slug: String!
  updatedAt: SequelizeDate!
}

type CasinoGameLobbyEdge {
  node: CasinoGameLobby
  cursor: String!
}

type CasinoGameLobbyConnection {
  pageInfo: PageInfo!
  edges: [CasinoGameLobbyEdge!]
  total: Int
}

input PositionedCasinoGameInput {
  index: Int!
  casinoGameId: ID!
}

input CreateCasinoGameLobbyInput {
  name: String!
  order: Int
  positionedCasinoGameInputs: [PositionedCasinoGameInput!]
  slug: String
}

type CreateCasinoGameLobbyPayload {
  casinoGameLobby: CasinoGameLobby!
}

input UpdateCasinoGameLobbyInput {
  casinoGameLobbyId: ID!
  name: String
  order: Int
  positionedCasinoGameInputs: [PositionedCasinoGameInput!]
  slug: String
}

type UpdateCasinoGameLobbyPayload {
  casinoGameLobby: CasinoGameLobby!
}

enum CasinoGameLobbyOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  ORDER
  ORDER_DESC
}

type CasinoGameProviderConfig implements Node {
  casinoGameId: ID!
  casinoGame: CasinoGame!
  casinoGameProviderId: ID!
  createdAt: SequelizeDate!
  devices: [Device!]
  featureGroup: CasinoGameFeatureGroup!
  id: ID!
  identifier: String!
  payout: Float
  updatedAt: SequelizeDate!
  volatilityRating: CasinoGameVolatilityRating
}

type CasinoGameProviderConfigConnection {
  pageInfo: PageInfo!
  edges: [CasinoGameProviderConfigEdge]
  total: Int
}

type CasinoGameProviderConfigEdge {
  node: CasinoGameProviderConfig
  cursor: String!
}

input CreateCasinoGameProviderConfigInput {
  casinoGameId: ID
  casinoGameProviderId: ID!
  devices: [Device!]
  featureGroup: CasinoGameFeatureGroup!
  identifier: String!
  payout: Int
  volatilityRating: CasinoGameVolatilityRating
}

input UpdateCasinoGameProviderConfigInput {
  casinoGameId: ID
  casinoGameProviderId: ID
  devices: [Device!]
  featureGroup: CasinoGameFeatureGroup
  id: ID!
  identifier: String
  payout: Int
  volatilityRating: CasinoGameVolatilityRating
}

enum CasinoGameProviderConfigOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum CasinoGameVolatilityRating {
  LOW
  MEDIUM_LOW
  MEDIUM
  MEDIUM_HIGH
  HIGH
  VERY_HIGH
}

type CasinoGameProvider implements Node {
  createdAt: SequelizeDate!
  id: ID!
  monthlyFeeBasic: Int!
  monthlyFeeBrand: Int
  monthlyFeeJackpot: Int
  monthlyFeePartners: Int
  monthlyFeePremium: Int
  monthlyFeeTable: Int
  provider: CasinoGameProviderCode!
  subProvider: CasinoGameProviderCode!
  studio: CasinoGameProviderCode!
  studioDisplayValue: String
  enabled: Boolean!
  updatedAt: SequelizeDate!
}

type CasinoGameProviderConnection {
  pageInfo: PageInfo!
  edges: [CasinoGameProviderEdge]
  total: Int
}

type CasinoGameProviderEdge {
  node: CasinoGameProvider
  cursor: String!
}

type CasinoGameProviderTotalGamesPayload {
  provider: CasinoGameProviderCode
  providerDisplayValue: String
  totalGames: Int
}

type AddCasinoGameProviderGamesPayload {
  success: Boolean!
}

input AddCasinoGameProviderGamesInput {
  provider: CasinoGameProviderCode!
  featureGroupToAdd: [String]!
  subProviderToLoadGames: CasinoGameProviderCode!
}

input CreateCasinoGameProviderInput {
  monthlyFeeBasic: Int!
  monthlyFeeBrand: Int
  monthlyFeeJackpot: Int
  monthlyFeePartners: Int
  monthlyFeePremium: Int
  monthlyFeeTable: Int
  provider: CasinoGameProviderCode!
  subProvider: CasinoGameProviderCode!
  studio: CasinoGameProviderCode!
  enabled: Boolean!
}

input UpdateCasinoGameProviderInput {
  id: ID!
  monthlyFeeBasic: Int
  monthlyFeeBrand: Int
  monthlyFeeJackpot: Int
  monthlyFeePartners: Int
  monthlyFeePremium: Int
  monthlyFeeTable: Int
  provider: CasinoGameProviderCode
  subProvider: CasinoGameProviderCode
  studio: CasinoGameProviderCode
  enabled: Boolean
}

enum CasinoGameProviderOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type CasinoGameRound implements Node {
  id: ID!
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
  finishedAt: SequelizeDate
  status: CasinoGameRoundStatus!
  currency: String!
  externalId: String!
  casinoGameSessionId: ID!
  casinoGameSession: CasinoGameSession!
  totalBet: Float
  totalWin: Float
  userId: ID!
  user: User!
  actions(after: String, first: PaginationAmount, before: String, last: PaginationAmount): CasinoGameActionConnection!
  rakebackGenerated: Float
}

type CasinoGameRoundConnection {
  pageInfo: PageInfo!
  pages: [String]
  edges: [CasinoGameRoundEdge]
  total: Int
}

type CasinoGameRoundEdge {
  node: CasinoGameRound
  cursor: String!
}

enum CasinoGameRoundOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum CasinoGameRoundStatus {
  CREATED
  CANCELLED
  COMPLETED
  NOTIFIED
}

type CasinoGameSession implements Node {
  casinoGameProviderConfigId: ID!
  casinoGameProviderConfig: CasinoGameProviderConfig!
  createdAt: SequelizeDate!
  currency: String!
  gameUrl: String
  strategy: CasinoGameSessionStrategy
  id: ID!
  ipAddress: String
  locale: String
  updatedAt: SequelizeDate!
  userId: ID!
  totalBet: Float
  baseTotalBet: Float
  totalPayout: Float
  baseTotalPayout: Float
  totalProfit: Float
  baseTotalProfit: Float
  baseCurrency: String
  userCurrency: String
  baseCurrencyRate: Float
}

type CasinoGameSessionPayload {
  gameUrl: String!
  strategy: CasinoGameSessionStrategy!
  properties: JSON
}

type CasinoGameSessionConnection {
  pageInfo: PageInfo!
  edges: [CasinoGameSessionEdge]
  total: Int
}

type CasinoGameSessionEdge {
  node: CasinoGameSession
  cursor: String!
}

input StartCasinoGameSessionInput {
  currency: String
  gameId: ID
  slug: String
  isDemo: Boolean!
  locale: String
  deviceType: Device!
  depositUrl: String!
  returnUrl: String!
}

enum CasinoGameSessionOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum CasinoGameSessionStrategy {
  DETECT
  IFRAME
  REDIRECT
}

type CasinoGame implements Node {
  asset(width: Int, height: Int): Asset
  assets: [Asset!]
  availableFeatureGroups: [CasinoGameFeatureGroup!]
  availableProviders: [CasinoGameProvider!]
  casinoGameProviderConfigs: [CasinoGameProviderConfig!]
  casinoGameSelectedProvider: CasinoGameProvider!
  casinoGameSelectedProviderId: ID
  category: CasinoGameCategory
  createdAt: SequelizeDate
  description: String
  enabled: Boolean
  hasFreeSpins: Boolean
  height: Int
  id: ID!
  isLive: Boolean
  lines: Int
  order: Int
  recalledAt: SequelizeDate
  releasedAt: SequelizeDate
  selectedFeatureGroup: CasinoGameFeatureGroup
  slug: String!
  studio: CasinoGameProviderCode
  studioDisplayValue: String
  title: String
  updatedAt: SequelizeDate
  width: Int
}

type CasinoGameConnection {
  pageInfo: PageInfo!
  edges: [CasinoGameEdge]
  total: Int
}

type CasinoGameEdge {
  node: CasinoGame
  cursor: String!
}

type ResolveCasinoGameImagesPayload {
  success: Boolean!
}

type UpdateCasinoGameSubscriptionPayload {
  casinoGame: CasinoGame!
}

input CreateCasinoGameInput {
  assetIds: [ID!]
  casinoGameSelectedProviderId: ID!
  category: CasinoGameCategory!
  description: String
  enabled: Boolean!
  hasFreeSpins: Boolean
  height: Int
  isLive: Boolean
  lines: Int
  order: Int
  recalledAt: SequelizeDate
  releasedAt: SequelizeDate
  selectedFeatureGroup: CasinoGameFeatureGroup
  slug: String!
  studio: CasinoGameProviderCode
  title: String!
  width: Int
}

input UpdateCasinoGameInput {
  assetIds: [ID!]
  casinoGameSelectedProviderId: ID
  category: CasinoGameCategory
  description: String
  enabled: Boolean
  hasFreeSpins: Boolean
  height: Int
  id: ID!
  isLive: Boolean
  lines: Int
  order: Int
  recalledAt: SequelizeDate
  releasedAt: SequelizeDate
  selectedFeatureGroup: CasinoGameFeatureGroup
  slug: String
  studio: CasinoGameProviderCode
  title: String
  width: Int
}

enum CasinoGameOrderBy {
  ID
  ID_DESC
  CATEGORY
  CATEGORY_DESC
  CREATED_AT
  CREATED_AT_DESC
  ORDER
  ORDER_DESC
  STUDIO
  STUDIO_DESC
  TITLE
  TITLE_DESC
}

enum CasinoGameCategory {
  CARD
  CASUAL
  CRAPS
  CRASH
  FISHING
  LOTTERY
  POKER
  ROULETTE
  SLOTS
  VIDEO_POKER
  VIRTUAL_SPORTS
}

enum CasinoGameFeatureGroup {
  BASIC
  BASIC_RTP
  BASIC_RTP94
  NEW
  LOW
  MEDIUM
  HIGH
}

enum Device {
  MOBILE
  DESKTOP
}

enum CasinoGameProviderCode {
  ACCEPTANCE
  AINSWORTH
  AIRDICE
  ALG
  ALL41STUDIOS
  ALTENAR
  AMATIC
  ATMOSFERA
  ATMOSPHERA
  AUTHENTIC
  AVATARUX
  BADDINGO
  BALLY
  BALLYWULFF
  BANGBANGGAMES
  BARCREST
  BBGAMES
  BELATRA
  BET2TECH
  BGAMING
  BIGTIMEGAMING
  BLUEPRINT
  BOOMERANGSTUDIOS
  BOOMING
  BOOONGO
  BSG
  BULLETPROOF
  CALETA
  CASHPOINT
  CRAZYTOOTH
  DICELABS
  EAGAMING
  EDICT
  EGT
  ELECTRICELEPHANT
  ELK
  ENDORPHINA
  EPICMEDIA
  EVERYMATRIX
  EVOLUTION
  EVOPLAY
  EZUGI
  FANTASMA
  FANTASMAGAMES
  FAZI
  FELIXGAMING
  FOXIUM
  FUGASO
  GAMEART
  GAMEBEAT
  GAMEBURGERSTUDIOS
  GAMESINC
  GAMEVY
  GAMING1
  GAMOMAT
  GAMZIX
  GOLDENHERO
  GOLDENRACE
  GREENJADE
  GROOVE
  HABANERO
  HACKSAW
  HACKSAWGAMING
  HIGH5
  HOLLEGAMES
  HOTRISEGAMES
  HUB88
  IGTECH
  INFIN
  INSPIRED
  IRONDOG
  IRONDOGSTUDIO
  ISB
  ISOFTBET
  JADERABBIT
  KAGAMING
  KALAMBA
  KIRON
  LEANDER
  LEANDERGAMES
  LEAPGAMING
  LIGHTNINGBOX
  LIGHTWONDER
  LUCKY
  LUCKYSTREAK
  MANCALA
  MASCOT
  MAXWINGAMING
  MEN
  MERKUR
  MICROGAMING
  MOJOS
  MRSLOTTY
  NEKOGAMES
  NETENT
  NETGAME
  NEXTGEN
  NOLIMIT
  NOLIMITCITY
  NORTHERNLIGHTS
  NOVOMATIC
  NUCLEUS
  NYX
  ONETOUCH
  ONEXTWOGAMING
  ONLYPLAY
  ORYX
  PARIPLAY
  PEARFICTION
  PETERSONS
  PGSOFT
  PINNACLE
  PIPA
  PLATIPUS
  PLAYNGO
  PLAYSON
  PLAYTECH
  PRAGMATICEXTERNAL
  PRAGMATICPLAY
  PRAGMATICPLAYLIVE
  PUSHGAMING
  QUICKFIRE
  QUICKSPIN
  RABCAT
  REALDEALER
  RED7
  REDRAKE
  REDTIGER
  REELLIFEGAMES
  REELPLAY
  REELTIMEGAMING
  REEVO
  REFLEXGAMING
  RELAX
  RETROGAMING
  SAPPHIRE
  SGDIGITAL
  SHUFFLEMASTER
  SIDECITY
  SLOTEGRATOR
  SLOTMILL
  SMARTSOFT
  SNOWBORN
  SOFTSWISS
  SPEARHEAD
  SPIN4WIN
  SPINOMENAL
  SPINPLAY
  SPRIBE
  STAKELOGIC
  STHLMGAMING
  SWINTT
  TECHNOLOGY
  TEST
  THEPLAYER
  THUNDERKICK
  TMA
  TOMHORN
  TRUELAB
  TVBET
  WAZDAN
  WIZARD
  WMS
  X2GAMING
  YGGDRASIL
  VIVOGAMING
  ZILLION
}

type Country {
  dialCode: String
  code: String
  name: String
  flag: String
  currency: String
  enabled: Boolean
  european: Boolean
  minimumAge: Int
}

type CrashBetItem implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  crashBetId: ID!
  crashBet: CrashBet
  itemVariantId: ID!
  itemVariant: ItemVariant
  userItemId: ID
  userItem: UserItem
}

type CrashBetItemConnection {
  pageInfo: PageInfo!
  edges: [CrashBetItemEdge]
  total: Int
}

type CrashBetItemEdge {
  node: CrashBetItem
  cursor: String!
}

enum CrashBetItemOrderBy {
  ID
  ID_DESC
}

type CrashBet implements Node {
  id: ID!
  tick: Int
  maxTick: Int
  amount: Float
  totalBet: Float
  totalWinAmount: Float
  remainderWinAmount: Float
  mode: CrashBetMode!
  currency: String!
  desiredItemVariantId: ID
  desiredItemVariant: ItemVariant
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  userId: ID!
  user: User!
  userItemId: ID
  userItem: UserItem
  gameId: ID
  game: CrashGame
  items(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [CrashBetItemOrderBy]): CrashBetItemConnection
  ticketsWon: Int!
  gameProviderFeePercent: Float
  affiliateUserId: ID
  rakeback: Float
}

type CrashBetConnection {
  pageInfo: PageInfo!
  edges: [CrashBetEdge]
  total: Int
}

type CrashBetEdge {
  node: CrashBet
  cursor: String!
}

type CrashBetItemVariantConnection {
  pageInfo: PageInfo!
  edges: [CrashBetItemVariantEdge]
  total: Int
}

type CrashBetItemVariantEdge {
  node: ItemVariant
  cursor: String!
}

type CreateCrashBetPayload {
  crashBet: CrashBet
}

type ExitCrashPayload {
  crashBet: CrashBet
}

type CreateCrashBetSubscriptionPayload {
  crashBet: CrashBet!
}

type UpdateCrashBetSubscriptionPayload {
  crashBet: CrashBet!
}

type CrashBetStats {
  commonAmounts: [Float!]!
  commonMaxTicks: [Int!]!
}

input CreateCrashBetInput {
  amount: Float!
  desiredItemVariantId: ID
  gameId: ID
  maxTick: Int
  mode: CrashBetMode
  userItemIds: [ID]!
}

input ExitCrashInput {
  betId: ID!
  secret: String
}

enum CrashBetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum CrashBetMode {
  COINS_ONLY
  ITEMS_AND_COINS
}

type CrashGame implements Node {
  id: ID!
  status: CrashGameStatus!
  seed: String
  roll: Int
  startedAt: SequelizeDate!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  scheduledAt: SequelizeDate
  totalBetCount: Float
  totalUserCount: Float
  totalBet: Float
  totalPayout: Float
  currency: String!
  bets(after: String, first: PaginationAmount, before: String, last: PaginationAmount): CrashBetConnection
}

type CrashGameConnection {
  pageInfo: PageInfo!
  edges: [CrashGameEdge]
  total: Int
}

type CrashGameEdge {
  node: CrashGame
  cursor: String!
}

type CreateCrashGameSubscriptionPayload {
  crashGame: CrashGame!
}

type UpdateCrashGameSubscriptionPayload {
  crashGame: CrashGame!
}

enum CrashGameOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum CrashGameStatus {
  CREATED
  STARTED
  FINISHED
}

type CronJob implements Node {
  id: ID!
  name: String!
  description: String!
  schedule: String!
  timeZone: String!
  userUpdateTime: SequelizeDate
  state: SchedulerState!
  status: JSON
  scheduleTime: SequelizeDate
  lastAttemptTime: SequelizeDate
  retryConfig: JSON
  attemptDeadline: SequelizeDate
  pubsubTarget: JSON
  appEngineHttpTarget: JSON
  httpTarget: JSON
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type CronJobConnection {
  pageInfo: PageInfo!
  edges: [CronJobEdge]
  total: Int
}

type CronJobEdge {
  node: CronJob
  cursor: String!
}

type CreateCronJobPayload {
  cronJob: CronJob
}

type DeleteCronJobPayload {
  cronJob: CronJob
}

type PauseCronJobPayload {
  cronJob: CronJob
}

type ResumeCronJobPayload {
  cronJob: CronJob
}

input CreateCronJobInput {
  name: String!
  appEngineHttpTarget: SchedulerAppEngineHttpTargetInput
  description: String!
  httpTarget: SchedulerHttpTargetInput
  pubsubTarget: SchedulerPubsubTargetInput
  retryConfig: SchedulerRetryConfigInput
  schedule: String!
  timeZone: String!
}

input SchedulerDurationInput {
  seconds: Int
  nanos: Int
}

input SchedulerRetryConfigInput {
  retryCount: Int
  maxRetryDuration: SchedulerDurationInput
  minBackoffDuration: SchedulerDurationInput
  maxBackoffDuration: SchedulerDurationInput
  maxDoublings: Int
}

input SchedulerHttpTargetInput {
  uri: String
  httpMethod: SchedulerHttpMethod
  headers: JSON
  body: String
}

input SchedulerPubsubTargetInput {
  topicName: String
  data: String
  attributes: JSON
}

input SchedulerAppEngineHttpTargetInput {
  httpMethod: SchedulerHttpMethod
  appEngineRouting: SchedulerAppEngineRoutingInput
  relativeUri: String
  headers: JSON
  body: String
}

input SchedulerAppEngineRoutingInput {
  service: String
  version: String
  instance: String
  host: String
}

input DeleteCronJobInput {
  name: String!
}

input PauseCronJobInput {
  name: String!
}

input ResumeCronJobInput {
  name: String!
}

enum SchedulerState {
  ENABLED
  DISABLED
  PAUSED
  STATE_UNSPECIFIED
  UPDATE_FAILED
}

enum CronJobOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum SchedulerHttpMethod {
  HTTP_METHOD_UNSPECIFIED
  POST
  GET
  HEAD
  PUT
  DELETE
  PATCH
  OPTIONS
}

type CryptoAddress {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  address: String!
  default: Boolean!
  label: String
  paymentOption: PaymentOption!
  paymentOptionId: ID!
  type: CryptoAddressType
  user: User!
  userId: ID!
}

type CryptoAddressConnection {
  pageInfo: PageInfo!
  edges: [CryptoAddressEdge]
  total: Int
}

type CryptoAddressEdge {
  node: CryptoAddress
  cursor: String!
}

type CryptoAddressPayload {
  cryptoAddress: CryptoAddress!
}

input CreateCryptoAddressInput {
  address: String
  default: Boolean
  ignoreExisting: Boolean
  label: String
  paymentOptionId: ID!
  userId: ID
}

input DeleteCryptoAddressInput {
  cryptoAddressId: ID!
}

input UpdateCryptoAddressInput {
  address: String
  cryptoAddressId: ID!
  default: Boolean
  label: String
  paymentOptionId: ID
  userId: ID
}

enum CryptoAddressOrderBy {
  ID
  ID_DESC
}

enum CryptoAddressType {
  DEPOSIT
  WITHDRAWAL
}

type Dashboard {
  transactions(currency: String, status: TransactionStatus, type: TransactionType, minDate: SequelizeDate, maxDate: SequelizeDate): TransactionStats
  transactionsExpanded(currency: String, maxDate: SequelizeDate, minDate: SequelizeDate, status: TransactionStatus, type: TransactionType): [TransactionsExpandedStatProvider!]
  registrations(minDate: SequelizeDate, maxDate: SequelizeDate): Float
  games(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, includeExcluded: Boolean): GameStats
  gameJackpots(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate): GameJackpotStats
  jackpotWinningTickets(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate): JackpotWinningTicketsStats
  crashGames(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, includeExcluded: Boolean): CrashGameStats
  boxOpenings(currency: String, hasPvpGame: Boolean, minDate: SequelizeDate, maxDate: SequelizeDate, minValue: Float, maxValue: Float, maxLevel: Int, minLevel: Int, type: BoxType, includeExcluded: Boolean, walletType: [WalletType!], slotTypes: [BoxSlotType!]): BoxOpeningStats
  diceBets(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, includeExcluded: Boolean, gameTypes: [DiceGameType!]): DiceBetStats
  matchBettingSlips(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, includeExcluded: Boolean): MatchBettingSlipStats
  pvpGames(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, includeExcluded: Boolean, types: [PvpGameType!], isMultiplierBoxGame: Boolean @deprecated(reason: "Use multiplierModes instead"), multiplierModes: [PvpGameMultiplierMode!]): PvpGameStats
  pvpBotGames(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, includeExcluded: Boolean, types: [PvpGameType!], multiplierModes: [PvpGameMultiplierMode!]): PvpGameStats
  promoRedemptions(currency: String, type: PromoCodeType, minDate: SequelizeDate, maxDate: SequelizeDate): PromoCodeRedemptionStats
  giveaways(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, walletType: [WalletType!]): GiveawayStats
  exchanges(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate): ExchangeStats
  orders(currency: String, creatorId: ID, userId: ID, minDate: SequelizeDate, maxDate: SequelizeDate, retailer: Retailer @deprecated(reason: "Use retailerId"), retailerId: ID): OrderStats
  plinkoBets(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, includeExcluded: Boolean): PlinkoBetStats
  walletChanges(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, userId: ID, type: [WalletChangeType], excludeStaff: Boolean): [WalletChangeStats!]!
  totalWalletValue(currency: String, name: WalletType): WalletStats!
  userItems(currency: String, createdAtMinDate: SequelizeDate, createdAtMaxDate: SequelizeDate, requestedAtMinDate: SequelizeDate, requestedAtMaxDate: SequelizeDate, updatedAtMinDate: SequelizeDate, updatedAtMaxDate: SequelizeDate, status: [UserItemStatus!], userId: ID, creatorId: ID, retailer: Retailer @deprecated(reason: "Use retailerId"), retailerId: ID): UserItemStats
  userProgressChanges(minDate: SequelizeDate, maxDate: SequelizeDate, userId: ID, source: [UserProgressSource], excludeStaff: Boolean): [UserProgressChangeStats!]!
  trades(bySupplier: Boolean, currency: String, status: [TradeStatus!], deposits: Boolean, createdAtMinDate: SequelizeDate, createdAtMaxDate: SequelizeDate, updatedAtMinDate: SequelizeDate, updatedAtMaxDate: SequelizeDate, userId: ID): TradeStats
  waxPeerTrades(currency: String, status: [WaxPeerTradeStatus!], createdAtMinDate: SequelizeDate, createdAtMaxDate: SequelizeDate, updatedAtMinDate: SequelizeDate, updatedAtMaxDate: SequelizeDate, userId: ID): WaxPeerTradeStats
  zbtTrades(currency: String, status: [ZbtTradeStatus!], createdAtMinDate: SequelizeDate, createdAtMaxDate: SequelizeDate, updatedAtMinDate: SequelizeDate, updatedAtMaxDate: SequelizeDate, userId: ID): ZbtTradeStats
  casinoGameActions(currency: String, minDate: SequelizeDate, maxDate: SequelizeDate, includeExcluded: Boolean): CasinoGameStats
}

type WalletStats {
  currency: String!
  totalValue: Float!
}

type WalletChangeStats {
  currency: String
  type: WalletChangeType
  totalValueChange: Float
  walletType: String
}

type TransactionStats {
  provider: [TransactionStatProvider]
}

type TransactionStatProvider {
  count: Int
  totalAmount: Float
  provider: PaymentProvider
  currency: String!
}

type TransactionsExpandedStatProvider {
  currency: String!
  entries: [TransactionsExpandedStatPaymentOption!]!
  provider: PaymentProvider!
  totalAmount: Float!
  totalCount: Int!
}

type TransactionsExpandedStatPaymentOption {
  average: Float!
  averageOriginal: Float!
  currency: String!
  currencyOriginal: String!
  maxAmount: Float!
  maxAmountOriginal: Float!
  methodName: String!
  minAmount: Float!
  minAmountOriginal: Float!
  paymentOptionId: ID
  providerName: String!
  totalAmount: Float!
  totalAmountOriginal: Float!
  totalCount: Int!
}

type ExchangeStats {
  count: Int
  userItemsValue: Float
  itemsValue: Float
  remainder: Float
  profit: Float
  currency: String!
}

type GameStats {
  count: Int
  totalBetCount: Int
  totalUserCount: Int
  totalBet: Float
  totalPayout: Float
  currency: String!
}

type GameJackpotStats {
  count: Int
  totalInitialValue: Float
  totalValue: Float
  totalWageredValue: Float
  currency: String!
}

type JackpotWinningTicketsStats {
  count: Int
  totalUserItemAcquiredValue: Float
  currency: String!
}

type DiceBetStats {
  count: Int
  totalBet: Float
  totalPayout: Float
  totalProfit: Float
  currency: String!
}

type OrderStats {
  count: Int
  cost: Float
  deliveryCost: Float
  currency: String!
}

type CrashGameStats {
  count: Int
  totalBetCount: Int
  totalUserCount: Int
  totalBet: Float
  totalPayout: Float
  currency: String!
}

type BoxOpeningStats {
  count: Int
  totalBalance: Float
  totalBoxValue: Float
  totalGemstones: Float
  totalItemValue: Float
  totalJackpotTickets: Int
  totalPayout: Float
  totalProfit: Float
  totalWonBoxValue: Float
  totalXp: Float
  currency: String!
}

type PromoCodeRedemptionStats {
  count: Float
  balance: Float
  currency: String!
}

type GiveawayStats {
  count: Int!
  totalRewardAmount: Float!
  currency: String!
}

type MatchBettingSlipStats {
  count: Int
  activeCount: Int
  rollbackCount: Int
  totalActiveBet: Float
  totalActivePayout: Float
  totalBet: Float
  totalPayout: Float
  totalRollbackBet: Float
  totalRollbackPayout: Float
  currency: String!
  videoGames: [VideoGameMatchBettingSlipStats!]
}

type PlinkoBetStats {
  avgHouseEdgePercent: Float
  maxHouseEdgePercent: Float
  minHouseEdgePercent: Float
  count: Int
  totalBet: Float
  totalPayout: Float
  totalProfit: Float
  currency: String!
}

type PvpGameStats {
  count: Int
  totalBetCount: Int
  totalBet: Float
  totalHouseEdge: Float
  totalPayout: Float
  currency: String!
}

type UserItemStats {
  count: Int
  acquiredValue: Float
  consumedValue: Float
  currentValue: Float
  currency: String!
}

type UserProgressChangeStats {
  source: UserProgressSource
  totalValueChange: Int
}

type TradeStats {
  count: Int
  currentValue: Float
  currency: String!
}

type VideoGameMatchBettingSlipStats {
  stats: MatchBettingSlipStats!
  videoGame: MatchBettingVideoGame!
}

type WaxPeerTradeStats {
  count: Int
  value: Float
  valuePaid: Float
  currency: String!
}

type ZbtTradeStats {
  count: Int
  value: Float
  valuePaid: Float
  currency: String!
}

type CasinoGameStats {
  count: Int
  totalBet: Float
  totalPayout: Float
  totalProfit: Float
  currency: String!
}

type DiceBetItem {
  itemVariantId: ID!
  itemVariant: ItemVariant!
  userItemId: ID!
  userItem: UserItem!
  value: Float!
}

type DiceBet implements Node {
  id: ID!
  userId: ID!
  user: User!
  rollId: ID!
  roll: Roll!
  amount: Float!
  currency: String!
  totalBet: Float!
  totalRemainderPayout: Float!
  totalPayout: Float!
  profit: Float!
  choice: DiceBetChoice!
  won: Boolean!
  chance: Float!
  houseEdgePercent: Float!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  betItems: [DiceBetItem!]
  ticketsWon: Int!
  gameType: DiceGameType!
  wonUserItemId: ID
  wonUserItem: UserItem
  desiredItemVariantId: ID
  desiredItemVariant: ItemVariant
  gameProviderFeePercent: Float
  affiliateUserId: ID
  rakeback: Float
}

type DiceBetConnection {
  pageInfo: PageInfo!
  edges: [DiceBetEdge]
  total: Int
}

type DiceBetEdge {
  node: DiceBet
  cursor: String!
}

type CreateDiceBetsPayload {
  diceBets: [DiceBet]
}

type CreateDiceBetsSubscriptionPayload {
  diceBets: [DiceBet!]
}

input CreateDiceBetsInput {
  amount: Float!
  chance: Float
  choice: DiceBetChoice!
  desiredItemVariantId: ID
  mode: DiceBetMode!
  rollsPerClick: Int!
  userItemIds: [ID!]!
}

enum DiceBetOrderBy {
  CHANCE_DESC
  CHANCE
  ID_DESC
  ID
  PROFIT_DESC
  PROFIT
  TOTAL_BET_DESC
  TOTAL_BET
}

enum DiceBetMode {
  ANIMATION
  AUTO
  BATCH
  MANUAL
}

enum DiceBetChoice {
  OVER
  UNDER
}

enum DiceGameType {
  DICE
  UPGRADE
}

type DigitalCode implements Node {
  id: ID!
  itemVariantIds: [ID!]!
  itemVariants: [ItemVariant!]!
  code: String
  userId: ID
  user: User
  userItemId: ID
  userItem: UserItem
  consumedAt: SequelizeDate
  creatorId: ID
  creator: User
  deletorId: ID
  deletor: User
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
}

type DigitalCodeConnection {
  pageInfo: PageInfo!
  edges: [DigitalCodeEdge]
  total: Int
}

type DigitalCodeEdge {
  node: DigitalCode
  cursor: String!
}

type CreateDigitalCodePayload {
  ids: [ID!]!
}

type DeleteDigitalCodePayload {
  digitalCode: DigitalCode!
}

type CreateDigitalCodeSubscriptionPayload {
  digitalCode: DigitalCode!
}

type UpdateDigitalCodeSubscriptionPayload {
  digitalCode: DigitalCode!
}

type DeleteDigitalCodeSubscriptionPayload {
  digitalCode: DigitalCode!
}

input CreateDigitalCodesInput {
  codes: [String!]!
  itemVariantIds: [ID!]!
}

enum DigitalCodeOrderBy {
  ID
  ID_DESC
}

type Document implements Node {
  id: ID!
  verified: Boolean
  type: DocumentType
  userId: ID!
  user: User!
  assetId: ID
  asset: Asset
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate!
}

type DocumentConnection {
  pageInfo: PageInfo!
  edges: [DocumentEdge]
  total: Int
}

type DocumentEdge {
  node: Document
  cursor: String!
}

type CreateDocumentPayload {
  document: Document
}

type UpdateDocumentPayload {
  document: Document
}

type DeleteDocumentPayload {
  document: Document
}

type CreateDocumentSubscriptionPayload {
  document: Document!
}

type DeleteDocumentSubscriptionPayload {
  document: Document!
}

input CreateDocumentInput {
  userId: ID!
  type: DocumentType
  upload: [Upload!]
}

input UpdateDocumentInput {
  id: ID!
  type: DocumentType
  verified: Boolean
  upload: [Upload!]
}

input DeleteDocumentInput {
  id: ID!
}

enum DocumentOrderBy {
  ID
  ID_DESC
}

enum DocumentType {
  IDENTITY
  RESIDENCE
}

union DropCacheItemMeta = BoxOpening | DiceBet

type DropCacheItem {
  id: ID!
  value: Float!
  createdAt: SequelizeDate!
  type: DropCacheItemType!
  meta: DropCacheItemMeta
}

type DropCacheItemsPayload {
  latestDropCacheItems: [DropCacheItem!]!
  topDropCacheItems: [DropCacheItem!]!

  """
  Will return the top wins by x days, defined in box:cache_best_drops_time_days setting.
  """
  topDropCacheItemsByDays: [DropCacheItem!]!
  topDropBoxSlugCacheItems: [DropCacheItem!]!
  latestDropBoxSlugCacheItems: [DropCacheItem!]!
  topDropBoxSlugByDaysCacheItems: [DropCacheItem!]!
}

type DropAddedRequestSubscriptionPayload {
  drop: DropCacheItem!
}

input GetDropCacheItemOptions {
  limit: Int!

  """Specify which drop types to include in list."""
  include: [DropCacheItemType!]!
  boxId: ID
}

input GetDropCacheItemsInput {
  latestDropCacheItemOptions: GetDropCacheItemOptions!

  """Leave undefined to omit top wins from results."""
  topDropCacheItemOptions: GetDropCacheItemOptions

  """Include top wins of the week or x days defined in settings."""
  topDropCacheItemByDaysOptions: GetDropCacheItemOptions

  """Include top wins of the week or top wins of a specific box."""
  topDropCacheBoxSlugItemOptions: GetDropCacheItemOptions

  """
  Indicates whether to automatically purge items in latests drops which are also included in top drops
  """
  purgeDuplicates: Boolean = false
}

enum DropCacheItemType {
  BOX_OPENING
  UPGRADE_WIN
}

"""
ISO 8601 Durations define the amount of intervening time in a time interval and are represented by the format P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W
"""
scalar Duration

type EmailWaitingList implements Node {
  id: ID!
  email: String!
  status: EmailWaitingListStatus!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type EmailWaitingListConnection {
  pageInfo: PageInfo!
  edges: [EmailWaitingListEdge]
  total: Int
}

type EmailWaitingListEdge {
  node: EmailWaitingList
  cursor: String!
}

type EmailWaitingListPayload {
  email: String!
  status: EmailWaitingListStatus!
}

input EmailWaitingListInput {
  email: String!
}

enum EmailWaitingListOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum EmailWaitingListStatus {
  INVITED
  WAITING
}

type CreateEmailPayload {
  emails: [String!]
  count: Int
  email: String
  title: String!
}

type SendSelfExclusionExpiredEmailPayload {
  email: String!
}

type ResubscribeUserToAllMarketingEmailsPayload {
  email: String!
}

input CreateEmailInput {
  userId: ID
  userIds: [ID!]
  title: String!
  message: String!
}

input SendSelfExclusionExpiredEmailInput {
  userId: ID!
  selfExcludeUntil: SequelizeDate!
  selfExcludeForHours: Int!
  secret: String!
}

input ResubscribeUserToAllMarketingEmailsInput {
  email: String!
  secret: String!
}

type ExchangeRate {
  currency: String
  provider: ExchangeRateProvider
  rate(reverse: Boolean): Float
}

type ExchangeRates {
  currency: String
  date: SequelizeDate
  rates: [ExchangeRate]
  updatedAt: SequelizeDate
}

type UpdateExchangeRatesPayload {
  success: Boolean!
}

input UpdateExchangeRatesInput {
  baseCurrencies: [String!]
  baseCurrency: String @deprecated(reason: "Use baseCurrencies instead")
  fiat: Boolean
  secret: String
}

enum ExchangeRateProvider {
  COIN_API
  COIN_LAYER
  FIXER
}

type Exchange implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  userItemsValue: Float!
  itemsValue: Float!
  remainder: Float!
  currency: String!
  profit: Float!
  userId: ID
  user: User
  itemVariants(after: String, first: PaginationAmount, before: String, last: PaginationAmount): ItemVariantConnection!
  userItems(after: String, first: PaginationAmount, before: String, last: PaginationAmount): UserItemConnection!
  newUserItems(after: String, first: PaginationAmount, before: String, last: PaginationAmount): UserItemConnection!
}

type ExchangeConnection {
  pageInfo: PageInfo!
  edges: [ExchangeEdge]
  total: Int
}

type ExchangeEdge {
  node: Exchange
  cursor: String!
}

type CreateExchangePayload {
  exchange: Exchange
}

input CreateExchangeInput {
  userItemIds: [ID!]!
  itemVariantIds: [ID!]!
  skipAffiliateBalance: Boolean
}

enum ExchangeOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type ForgotPasswordPayload {
  success: Boolean!
}

input ForgotPasswordInput {
  email: String!
  redirectUri: String!
  recaptcha: String!
  visualRecaptcha: String
}

type GameJackpotWinner implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  gameJackpotId: ID!
  gameJackpot: GameJackpot!
  amount: Float!
  currency: String!
  userId: ID!
  user: User!
}

type GameJackpotWinnerConnection {
  pageInfo: PageInfo!
  edges: [GameJackpotWinnerEdge]
  total: Int
}

type GameJackpotWinnerEdge {
  node: GameJackpotWinner
  cursor: String!
}

enum GameJackpotWinnerOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  AMOUNT
  AMOUNT_DESC
}

type GameJackpot implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  completedAt: SequelizeDate
  gameId: ID
  game: Game
  initialValue: Float!
  value: Float!
  winners(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [GameJackpotWinnerOrderBy]): GameJackpotWinnerConnection!
  totalValue: Float!
  currency: String!
  consecutiveCount: Int!
  wager: Float!
  payoutStructure: [GameJackpotPayoutStructure!]!
}

type GameJackpotConnection {
  pageInfo: PageInfo!
  edges: [GameJackpotEdge]
  total: Int
}

type GameJackpotEdge {
  node: GameJackpot
  cursor: String!
}

type UpdateGameJackpotPayload {
  gameJackpot: GameJackpot!
}

type CreateGameJackpotSubscriptionPayload {
  gameJackpot: GameJackpot!
}

type UpdateGameJackpotSubscriptionPayload {
  gameJackpot: GameJackpot!
}

type GameJackpotPayoutStructure {
  payoutPercent: Float!
}

type CompleteGameJackpotPayload {
  gameJackpot: GameJackpot
}

input CompleteGameJackpotInput {
  gameJackpotId: ID!
  gameId: ID
}

enum GameJackpotOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  VALUE
  VALUE_DESC
}

type GameMessage {
  body: String!
  gameId: ID!
  userId: ID!
}

type PvpGameMessage {
  body: String!
  pvpGameId: ID!
  userId: ID!
}

type CreateGameMessagePayload {
  gameMessage: GameMessage!
}

type CreateGameMessageSubscriptionPayload {
  gameMessage: GameMessage!
}

type CreatePvpGameMessagePayload {
  pvpGameMessage: PvpGameMessage!
}

type CreatePvpGameMessageSubscriptionPayload {
  pvpGameMessage: PvpGameMessage!
}

input CreateGameMessageInput {
  gameId: ID!
  body: String!
}

input CreatePvpGameMessageInput {
  pvpGameId: ID!
  body: String!
}

enum GameType {
  BOXES
  CRASH
  DICE
  MATCH_BETTING
  PLINKO
  PVP
  PVP_BOX
  PVP_COIN_FLIP
  PVP_DICE
  RANK_UP
  ROULETTE
  GEMSTONE
}

type Game implements Node {
  id: ID!
  rollId: ID
  roll: Roll
  maxPlayers: Int
  scheduledAt: SequelizeDate
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  status: GameStatus!
  totalBetCount: Float
  totalUserCount: Float
  totalBet: Float
  totalPayout: Float
  currency: String!
  bets(after: String, first: PaginationAmount, before: String, last: PaginationAmount): BetConnection!
  rollValue: Int
}

type GameConnection {
  pageInfo: PageInfo!
  edges: [GameEdge]
  total: Int
}

type GameEdge {
  node: Game
  cursor: String!
}

type RefreshCachedLatestGamesPayload {
  success: Boolean!
}

type FinishGamePayload {
  success: Boolean!
}

type CreateGameSubscriptionPayload {
  game: Game!
}

type RefreshCachedLatestGamesSubscriptionPayload {
  success: Boolean
}

type UpdateGameSubscriptionPayload {
  game: Game!
}

input RefreshCachedLatestGamesInput {
  secret: String
}

input FinishGameInput {
  gameId: ID!
  secret: String
}

enum GameOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum GameStatus {
  CREATED
  STARTED
  FINISHED
}

type GemstoneBoostActivation {
  id: ID!
  gemstoneBoostId: ID!
  gemstoneBoost: GemstoneBoost!
  userId: ID
  user: User
  teamId: ID
  team: Team
  amountMultiplier: Float
  activatedByAction: GemstoneBoostActivatedByAction!
  activatedByItemVariantId: ID
  activatedByItemVariant: ItemVariant
  activatedByUserId: ID
  activatedByUser: User
  startAt: SequelizeDate
  endAt: SequelizeDate
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
}

type GemstoneBoostActivationConnection {
  pageInfo: PageInfo!
  edges: [GemstoneBoostActivationEdge]
  total: Int
}

type GemstoneBoostActivationEdge {
  node: GemstoneBoostActivation
  cursor: String!
}

type CreateGemstoneBoostActivationPayload {
  gemstoneBoostActivation: GemstoneBoostActivation
}

enum GemstoneBoostActivatedByAction {
  ITEM_VARIANT_UNBOXING
  TOTAL_POINTS
}

enum GemstoneBoostActivationOrderBy {
  ID
  ID_DESC
}

type GemstoneBoost {
  id: ID!
  startAt: SequelizeDate!
  endAt: SequelizeDate!
  activationPeriod: Int!
  status: GemstoneBoostStatus!
  currency: String!
  walletType: WalletType!
  amountMultiplier: Float
  userGemstoneThreshold: Float
  teamGemstoneThreshold: Float
  teamBoostActivatedByItemVariantId: ID
  teamBoostActivatedByItemVariant: ItemVariant
  userBoostActivatedByItemVariantId: ID
  userBoostActivatedByItemVariant: ItemVariant
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
}

type GemstoneBoostTeamInfo {
  currentPoints: Float!
  pointThreshold: Int
  team: Team!
  teamId: ID!
  totalActivationsByItemVariant: Int!
  totalActivationsByPoints: Int!
  totalPoints: Float!
}

type GemstoneBoostUserInfo {
  currentPoints: Float!
  pointThreshold: Int
  totalActivationsByItemVariant: Int!
  totalActivationsByPoints: Int!
  totalPoints: Float!
  user: User!
  userId: ID!
}

type GemstoneBoostInfo {
  gemstoneBoost: GemstoneBoost
  teamsInfo: [GemstoneBoostTeamInfo!]!
  userInfo: GemstoneBoostUserInfo
}

type UpdateGemstoneBoostSubscriptionPayload {
  gemstoneBoostInfo: GemstoneBoostInfo!
}

type CreateGemstoneBoostPayload {
  gemstoneBoost: GemstoneBoost
}

type UpdateGemstoneBoostPayload {
  gemstoneBoost: GemstoneBoost
}

input CreateGemstoneBoostInput {
  activationPeriod: Int!
  amountMultiplier: Float!
  currency: String!
  endAt: SequelizeDate!
  startAt: SequelizeDate!
  status: GemstoneBoostStatus!
  teamGemstoneThreshold: Int
  walletType: WalletType
}

input UpdateGemstoneBoostInput {
  endAt: SequelizeDate
  gemstoneBoostId: ID!
  secret: String
  status: GemstoneBoostStatus
}

input ActivateBoostInput {
  userId: ID
  teamId: ID
  walletType: WalletType!
}

enum GemstoneBoostStatus {
  ENABLED
  DISABLED
}

type GemstoneGame implements Node {
  id: ID!
  betAmount: Float
  chance: Float
  currency: String
  walletType: WalletType
  winAmount: Float
  user: User!
  userId: ID!
  gemstoneBoostActivationId: ID
  gemstoneBoostActivation: GemstoneBoostActivation
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
}

type GemstoneGameConnection {
  pageInfo: PageInfo!
  edges: [GemstoneGameEdge]
  total: Int
}

type GemstoneGameEdge {
  node: GemstoneGame
  cursor: String!
}

type WinGemstoneSubscription {
  gemstone: GemstoneGame
}

type GemstoneGameLeaderboardBox {
  boxId: ID
  box: Box
  winAmount: Float
}

type GemstoneGameLeaderboard {
  board: [GemstoneGameLeaderboardNode]
  myItem: GemstoneGameLeaderboardNode
}

type GemstoneGameLeaderboardNode {
  boxes: [GemstoneGameLeaderboardBox]
  luck: Float @deprecated(reason: "Removed as too expensive")
  position: Int
  userId: ID
  user: User
  spent: Float
  winAmount: Float
}

enum GemstoneGameOrderBy {
  BET_AMOUNT_DESC
  BET_AMOUNT
  CREATED_AT_DESC
  CREATED_AT
  ID_DESC
  ID
  WIN_AMOUNT_DESC
  WIN_AMOUNT
}

type GeoTrack implements Node {
  id: ID!
  userId: ID!
  user: User!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  ip: String
  country: String
}

type GeoTrackSummary {
  countries: [GeoTrackSummaryItem!]!
  ips: [GeoTrackSummaryItem!]!
  totalCountries: [GeoTrackSummaryItem!]!
  totalIps: [GeoTrackSummaryItem!]!
}

type GeoTrackUserSummary {
  countries: [String!]!
  ips: [String!]!
  totalCountries: [GeoTrackSummaryItem!]!
  totalIps: [GeoTrackSummaryItem!]!
}

type GeoTrackSummaryItem {
  id: String!
  score: Int!
}

type GeoTrackConnection {
  pageInfo: PageInfo!
  edges: [GeoTrackEdge]
  total: Int
}

type GeoTrackEdge {
  node: GeoTrack
  cursor: String!
}

enum GeoTrackOrderBy {
  COUNTRY
  COUNTRY_DESC
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type GiftCardOption implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  enabled: Boolean!
  provider: GiftCardProvider!
  externalUrl: String!
  iconUrl: String!
  amount: Float!
  currency: String!
  marketId: ID!
  market: Market!
  order: Int
}

type GiftCardOptionConnection {
  pageInfo: PageInfo!
  edges: [GiftCardOptionEdge]
  total: Int
}

type GiftCardOptionEdge {
  node: GiftCardOption
  cursor: String!
}

type CreateGiftCardOptionPayload {
  giftCardOption: GiftCardOption
}

type UpdateGiftCardOptionPayload {
  giftCardOption: GiftCardOption
}

input CreateGiftCardOptionInput {
  amount: Float!
  enabled: Boolean!
  externalUrl: String!
  iconUrl: String!
  marketId: ID!
  order: Int
  provider: GiftCardProvider!
}

input UpdateGiftCardOptionInput {
  enabled: Boolean
  externalUrl: String
  giftCardOptionId: ID!
  iconUrl: String
  order: Int
}

enum GiftCardProvider {
  GAMIVO
  G2APAY
  KINGUIN
}

enum GiftCardOptionOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  ORDER
  ORDER_DESC
}

type Giveaway implements Node {
  id: ID!
  name: String
  status: GiveawayStatus!
  startAt: SequelizeDate
  endAt: SequelizeDate
  completedAt: SequelizeDate
  rewardAmount: Int!
  winnersAmount: Int!
  currency: String!
  totalEntries: Int!
  walletType: WalletType!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  entryRequirements: GiveawayEntryRequirements
}

type GiveawayConnection {
  pageInfo: PageInfo!
  edges: [GiveawayEdge]
  total: Int
}

type GiveawayEdge {
  node: Giveaway
  cursor: String!
}

type UpdateGiveawayPayload {
  giveaway: Giveaway
}

type CreateGiveawayPayload {
  giveaway: Giveaway
}

type AnnounceGiveawayPayload {
  message: Message
}

type GiveawayEntryRequirements {
  userLevel: Int
  userLastDepositAt: SequelizeDate
  userLastDepositAtIn: Duration
}

input CreateGiveawayInput {
  announceAtDates: [SequelizeDate!]
  currency: String!
  endAt: SequelizeDate
  endIn: Duration
  entryRequirements: GiveawayEntryRequirementsInput
  name: String
  rewardAmount: Float!
  secret: String
  startAt: SequelizeDate
  startIn: Duration
  walletType: WalletType!
  winnersAmount: Int!
}

input JoinGiveawayInput {
  giveawayId: ID!
  recaptcha: String!
  visualRecaptcha: String
}

input UpdateGiveawayInput {
  secret: String
  giveawayId: ID!
  status: GiveawayStatus!
}

input AnnounceGiveawayInput {
  secret: String
  giveawayId: ID!
}

input GiveawayEntryRequirementsInput {
  userLevel: Int
  userLastDepositAt: SequelizeDate
  userLastDepositAtIn: Duration
}

enum GiveawayStatus {
  CREATED
  COMPLETED
  ENDED
  STARTED
}

enum GiveawayOrderBy {
  COMPLETED_AT
  COMPLETED_AT_DESC
  CREATED_AT
  CREATED_AT_DESC
  END_AT
  END_AT_DESC
  ID
  ID_DESC
  START_AT
  START_AT_DESC
}

type InviteCode implements Node {
  id: ID!
  createdAt: SequelizeDate!
  deletedAt: SequelizeDate
  updatedAt: SequelizeDate!
  code: String
  redeemCount: Int
  increasedInviteCount: Int
  userId: ID
  user: User
}

type InviteCodeConnection {
  pageInfo: PageInfo!
  edges: [InviteCodeEdge]!
  total: Int
}

type InviteCodeEdge {
  node: InviteCode
  cursor: String!
}

type CreateInviteCodePayload {
  inviteCode: InviteCode!
}

type UpdateInviteCodePayload {
  inviteCode: InviteCode!
}

input CreateInviteCodeInput {
  code: String!
  userId: ID
}

input UpdateInviteCodeInput {
  code: String
  increaseInviteCountBy: Int
  inviteCodeId: ID!
}

enum InviteCodeOrderBy {
  ID
  ID_DESC
}

type ItemCategory {
  id: ID!
  name: String!
  order: Int
  shippingInfo: String
  items(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [ItemOrderBy], name: String, minValue: Float, maxValue: Float, obtainable: Boolean, usable: Boolean, withdrawable: Boolean, categoryId: ID): ItemConnection!
}

type ItemCategoryConnection {
  pageInfo: PageInfo!
  edges: [ItemCategoryEdge]
}

type ItemCategoryEdge {
  node: ItemCategory
  cursor: String!
}

type CreateCategoryPayload {
  itemCategory: ItemCategory
}

type UpdateCategoryPayload {
  itemCategory: ItemCategory
}

type CreateItemCategorySubscriptionPayload {
  itemCategory: ItemCategory!
}

type UpdateItemCategorySubscriptionPayload {
  itemCategory: ItemCategory!
}

type DeleteItemCategorySubscriptionPayload {
  itemCategory: ItemCategory!
}

input CreateItemCategoryInput {
  name: String!
  shippingInfo: String!
  defaultExchangeRate: Float!
  defaultMarkup: Float!
}

input UpdateItemCategoryInput {
  id: ID!
  name: String
  order: Int
  shippingInfo: String
  defaultExchangeRate: Float
  defaultMarkup: Float
}

input DeleteItemCategoryInput {
  id: ID!
}

enum ItemCategoryOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  ORDER
  ORDER_DESC
}

type ItemExternalMedia {
  url: String!
  mimeType: String!
  width: Int
  height: Int
}

type ItemVariant {
  id: ID!
  name: String
  value: Float!
  displayValue: Float!
  markup: Float!
  currency: String!
  itemId: ID!
  color: String
  size: String
  iconUrl: String!
  purchaseUrl: String
  obtainable: Boolean!
  usable: Boolean!
  withdrawable: Boolean!
  depositable: Boolean!
  purchasable: ItemPurchasable!
  categoryId: ID
  category: ItemCategory
  type: ItemType
  exchangeRate: Float!
  shippingCost: Float
  shippingInfo: String
  description: String
  brand: String
  rarity: String
  retailer: String @deprecated(reason: "Use retailerId")
  retailerId: ID
  retailerObject: RetailerType
  marketId: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  item: Item!
  releasedAt: SequelizeDate
  externalId: String
  approvalStrategy: ItemVariantApprovalStrategy
  availableAssets: [AvailableAsset!]
  totalRequested: Int
  totalAvailable: Int
  totalFulfilled: Int
  totalUnfulfilled: Int
  estimatedDeliveryInHours: String
}

type InventoryItemVariants {
  steamItems: [ItemVariant!]!
  activeTradeItems: [ItemVariant!]!
}

type Inventory {
  activeTradeItems: [ItemVariant!]!
  steamItems: [InventoryItem!]!
}

type InventoryItem {
  cacheExpiration: String
  itemVariant: ItemVariant!
  tradable: Boolean!
}

type ItemVariantConnection {
  pageInfo: PageInfo!
  edges: [ItemVariantEdge]
  total: Int
}

type ItemVariantEdge {
  node: ItemVariant
  cursor: String!
}

type CreateItemVariantPayload {
  itemVariant: ItemVariant
}

type UpdateItemVariantPayload {
  itemVariant: ItemVariant
}

type DeleteItemVariantPayload {
  itemVariant: ItemVariant
}

type CreateItemVariantSubscriptionPayload {
  itemVariant: ItemVariant!
}

type UpdateItemVariantSubscriptionPayload {
  itemVariant: ItemVariant!
}

type DeleteItemVariantSubscriptionPayload {
  itemVariant: ItemVariant!
}

type UpdateItemVariantsPayload {
  itemVariants: [ItemVariant]!
  total: Int
}

type AddUpdateItemVariantsTaskInputPayload {
  success: Boolean
}

type ItemVariantSize {
  categoryId: ID
  size: String
}

input CreateItemVariantInput {
  name: String
  value: Float!
  displayValue: Float!
  markup: Float!
  itemId: ID!
  iconUrl: String!
  purchaseUrl: String
  exchangeRate: Float!
  shippingCost: Float!
  shippingInfo: String
  color: String
  size: String
  description: String
  obtainable: Boolean
  usable: Boolean
  withdrawable: Boolean
  depositable: Boolean
  categoryId: ID
  brand: String
  rarity: String
  retailer: Retailer @deprecated(reason: "Use retailerId")
  retailerId: ID
  releasedAt: SequelizeDate
  externalId: String
  approvalStrategy: ItemVariantApprovalStrategy
  purchasable: ItemPurchasable
  type: ItemType
}

input UpdateItemVariantInput {
  itemVariantId: ID!
  name: String
  value: Float
  displayValue: Float
  markup: Float
  color: String
  size: String
  iconUrl: String
  purchaseUrl: String
  description: String
  obtainable: Boolean
  usable: Boolean
  withdrawable: Boolean
  depositable: Boolean
  categoryId: ID
  exchangeRate: Float
  shippingCost: Float
  shippingInfo: String
  brand: String
  rarity: String
  retailer: Retailer @deprecated(reason: "Use retailerId")
  retailerId: ID
  releasedAt: SequelizeDate
  externalId: String
  approvalStrategy: ItemVariantApprovalStrategy
  purchasable: ItemPurchasable
}

input DeleteItemVariantInput {
  id: ID!
}

enum ItemVariantOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DISPLAY_VALUE
  DISPLAY_VALUE_DESC
  RELEASED_AT
  RELEASED_AT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  VALUE
  VALUE_DESC
  AVAILABLE_ASSETS
  AVAILABLE_ASSETS_DESC
  HAS_AVAILABLE_ASSETS
  HAS_AVAILABLE_ASSETS_DESC
  TOTAL_REQUESTED
  TOTAL_REQUESTED_DESC
  SIZE
  SIZE_DESC
}

enum ItemVariantSizeOrderBy {
  ASC
  DESC
}

enum ItemVariantApprovalStrategy {
  AUTO
  MANUAL
}

enum ItemPurchasable {
  NOT_PURCHASABLE
  PURCHASABLE
  PURCHASABLE_WHEN_IN_STOCK
}

type Item implements Node {
  id: ID!
  name: String
  value: Float!
  currency: String!
  minValue: Float!
  maxValue: Float!
  minDisplayValue: Float!
  maxDisplayValue: Float!
  displayValue: Float
  exchangeRate: Float!
  externalMedia: [ItemExternalMedia!]
  markup: Float!
  shippingCost: Float
  iconUrl: String
  purchaseUrl: String
  categoryId: ID
  category: ItemCategory
  type: ItemType
  obtainable: Boolean!
  usable: Boolean!
  withdrawable: Boolean!
  description: String
  brand: String
  shippingInfo: String
  marketId: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  tags: [Tag!]
  users: [User]
  itemVariants: [ItemVariant]
  releasedAt: SequelizeDate
  externalId: String
  availableAssets: [AvailableAsset]
  minRarity: String
  maxRarity: String
  valueUpdatedAt: SequelizeDate
  valueRecentlyUpdated: Boolean!
  estimatedDeliveryInHours: String
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]
  total: Int
}

type ItemEdge {
  node: Item
  cursor: String!
}

type CreateItemPayload {
  item: Item
}

type CreateItemsPayload {
  items: [Item!]!
  total: Int
}

type CloneItemPayload {
  item: Item
}

type UpdateItemPayload {
  item: Item
}

type CreateItemSubscriptionPayload {
  item: Item!
}

type UpdateItemSubscriptionPayload {
  item: Item!
}

type UpdateItemMarkupsPayload {
  success: Boolean
}

type UpdateItemValuesPayload {
  success: Boolean
}

type UpdateItemDisplayValuesPayload {
  success: Boolean
}

type UpdateItemExchangeRatesPayload {
  success: Boolean
}

type SyncItemPricesPayload {
  success: Boolean
}

type SyncNewItemsPayload {
  success: Boolean
}

type FlattenItemPayload {
  success: Boolean
}

type AddSyncItemPricesTasksPayload {
  success: Boolean
}

input ItemTagInput {
  id: ID!
}

input ItemExternalMediaInput {
  url: String!
  mimeType: String!
  width: Int
  height: Int
}

input CreateItemInput {
  name: String
  value: Float!
  displayValue: Float!
  exchangeRate: Float!
  externalMedia: [ItemExternalMediaInput!]
  markup: Float!
  shippingCost: Float!
  iconUrl: String!
  purchaseUrl: String
  obtainable: Boolean
  usable: Boolean
  withdrawable: Boolean
  depositable: Boolean
  categoryId: ID
  marketId: ID!
  description: String!
  brand: String!
  shippingInfo: String!
  color: String
  size: String
  rarity: String
  releasedAt: SequelizeDate
  externalId: String
  tagIds: [ItemTagInput!]
  type: ItemType
}

input CloneItemInput {
  itemId: ID!
  targetMarketId: ID!
}

input UpdateItemInput {
  itemId: ID!
  name: String
  displayValue: Float
  exchangeRate: Float
  externalMedia: [ItemExternalMediaInput!]
  markup: Float
  shippingCost: Float
  iconUrl: String
  purchaseUrl: String
  obtainable: Boolean
  usable: Boolean
  withdrawable: Boolean
  categoryId: ID
  description: String
  brand: String
  shippingInfo: String
  releasedAt: SequelizeDate
  externalId: String
  tagIds: [ItemTagInput!]
}

input UpdateItemMarkupsInput {
  marketId: ID!
  categoryId: ID
  markup: Float!
}

input UpdateItemValuesInput {
  marketId: ID!
  categoryId: ID
  multiply: Float!
}

input UpdateItemDisplayValuesInput {
  marketId: ID!
  categoryId: ID
  multiply: Float!
}

input UpdateItemExchangeRatesInput {
  marketId: ID!
  categoryId: ID
  exchangeRate: Float!
}

input SyncItemPricesInput {
  itemType: ItemType!
  limit: Int
  maxId: Int
  minId: Int
  notify: Boolean
  secret: String
}

input SyncNewItemsInput {
  itemType: ItemType!
  limit: Int
  marketId: ID!
  notify: Boolean
  itemCategoryId: ID
  secret: String
}

input FlattenItemInput {
  itemId: ID
}

input AddSyncItemPricesTasksInput {
  itemType: ItemType!
  limit: Int
  notify: Boolean
  secret: String
}

enum ItemOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DISPLAY_VALUE
  DISPLAY_VALUE_DESC
  RELEASED_AT
  RELEASED_AT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  VALUE
  VALUE_DESC
  AVAILABLE_ASSETS
  AVAILABLE_ASSETS_DESC
  VALUE_UPDATED_AT
  VALUE_UPDATED_AT_DESC
}

enum ItemType {
  CODE
  CSGO
  DOTA2
  H1Z1
  IRL
  OSRS
  PUBG
  RUST
  STEAM
}

type JackpotWinningTicket implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  jackpotId: ID!
  jackpot: Jackpot!
  ticketId: ID!
  ticket: Ticket!
  itemVariantId: ID
  itemVariant: ItemVariant @deprecated(reason: "Use itemVariants instead")
  userItemId: ID
  userItem: UserItem @deprecated(reason: "Use userItems instead")
  userId: ID!
  user: User!
  position: Int
  balance: Float
  currency: String!
  walletType: WalletType
  totalValue: Float!
  itemVariantIds: [ID!]
  itemVariants: [ItemVariant!]
  userItemIds: [ID!]
  userItems: [UserItem!]
}

type JackpotWinningTicketConnection {
  pageInfo: PageInfo!
  edges: [JackpotWinningTicketEdge]
  total: Int
}

type JackpotWinningTicketEdge {
  node: JackpotWinningTicket
  cursor: String!
}

type JackpotWinningTicketSubscriptionPayload {
  jackpotWinningTicket: JackpotWinningTicket!
}

enum JackpotWinningTicketOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type GameWageringRequirement {
  gameType: GameType!
  wagerAmount: Float!
}

type Jackpot implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  scheduledAt: SequelizeDate
  gameWageringRequirements: [GameWageringRequirement!]!
  chance: Float!
  wager: Float!
  winnerCount: Int!
  initialValue: Float!
  value: Float!
  totalValue: Float!
  currency: String!
  won: Boolean!
  payoutConfig: JackpotPayoutConfig
  jackpotWinningTickets: [JackpotWinningTicket]!
  totalTickets: Int!
  ticketsInfo: JackpotTicketsInfo
  userRequirements: UserRequirements
  payoutType: JackpotPayoutType!
  wishlistTicketAmount: [JackpotWishlistTicketAmount!]
}

type JackpotConnection {
  pageInfo: PageInfo!
  edges: [JackpotEdge]
  total: Int
}

type JackpotEdge {
  node: Jackpot
  cursor: String!
}

type JackpotPayoutConfig {
  nextPosition: JackpotPayoutPosition
  positions: [JackpotPayoutPosition!]!
}

type JackpotPayoutPosition {
  percentage: Float
  balance: Float
  walletType: WalletType
  itemVariantId: ID
  itemVariant: ItemVariant
  scheduledAt: SequelizeDate
  totalValue: Float!
}

type CreateJackpotPayload {
  jackpot: Jackpot
}

type UpdateJackpotPayload {
  jackpot: Jackpot
}

type PayoutJackpotPayload {
  jackpot: Jackpot
}

type CreateJackpotSubscriptionPayload {
  jackpot: Jackpot!
}

type UpdateJackpotSubscriptionPayload {
  jackpot: Jackpot!
}

type RecalculateJackpotPayload {
  jackpot: Jackpot!
}

type RecalculateJackpotTicketsPayload {
  total: Int!
  ticketsInfo: JackpotTicketsInfo!
}

type PayoutJackpotTicketPayload {
  jackpotWinningTicket: JackpotWinningTicket
}

type CompleteJackpotPayload {
  jackpot: Jackpot!
}

type JackpotTicketsInfo {
  minId: Int
  maxId: Int
}

type JackpotWishlistTicketAmount {
  amount: Int!
  maxLevel: Int!
  minLevel: Int!
}

type JackpotLeaderboardElement implements Node {
  id: ID!
  userId: ID!
  user: User!
  totalTickets: Int!
  totalValue: Float!
}

type JackpotLeaderboardEdge {
  node: JackpotLeaderboardElement
  cursor: String!
}

type JackpotLeaderboardConnection {
  pageInfo: PageInfo!
  edges: [JackpotLeaderboardEdge!]!
}

input GameWageringRequirementInput {
  gameType: GameType!
  wagerAmount: Float!
}

input JackpotWishlistTicketAmountInput {
  amount: Int!
  maxLevel: Int!
  minLevel: Int!
}

input UserRequirementsInput {
  teamMember: Boolean
}

input CreateJackpotInput {
  chance: Float!
  wager: Float!
  initialValue: Int!
  payoutConfig: JackpotPayoutConfigInput
  gameWageringRequirements: [GameWageringRequirementInput!]!
  scheduledAt: SequelizeDate
  won: Boolean
  userRequirements: UserRequirementsInput
  currency: String
  payoutType: JackpotPayoutType
  wishlistTicketAmount: [JackpotWishlistTicketAmountInput!]
}

input UpdateJackpotInput {
  jackpotId: ID!
  chance: Float!
  wager: Float!
  initialValue: Int!
  payoutConfig: JackpotPayoutConfigInput
  gameWageringRequirements: [GameWageringRequirementInput!]!
  scheduledAt: SequelizeDate
  won: Boolean
  userRequirements: UserRequirementsInput
  payoutType: JackpotPayoutType
  wishlistTicketAmount: [JackpotWishlistTicketAmountInput!]
}

input JackpotPayoutConfigInput {
  positions: [JackpotPayoutPositionInput!]!
}

input JackpotPayoutPositionInput {
  percentage: Float
  balance: Float
  itemVariantId: ID
  walletType: WalletType
  scheduledAt: SequelizeDate
}

input RecalculateJackpotInput {
  secret: String
}

input RecalculateJackpotTicketsInput {
  jackpotId: ID!
  secret: String
}

input PayoutTicketInput {
  jackpotId: ID!
  position: Int
  scheduledAt: SequelizeDate
  secret: String
  sequentialNumber: Int
  teamId: ID
  ticketId: ID
}

input CompleteJackpotInput {
  jackpotId: ID!
}

enum JackpotOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  VALUE
  VALUE_DESC
}

enum JackpotPayoutType {
  REGULAR
  WISHLIST
}

type Asn {
  asn: String!
  domain: String!
  name: String!
  route: String!
  type: String!
}

type Carrier {
  name: String
  mcc: String
  mnc: String
}

type Currency {
  code: String
  name: String
  native: String
  plural: String
  symbol: String
}

type Language {
  name: String
  native: String
}

type Threat {
  isAnonymous: Boolean
  isBogon: Boolean
  isKnownAbuser: Boolean
  isKnownAttacker: Boolean
  isProxy: Boolean
  isThreat: Boolean
  isTor: Boolean
}

type TimeZone {
  abbr: String
  currentTime: String
  isDst: Boolean
  name: String
  offset: String
}

type Location {
  asn: Asn!
  callingCode: String
  carrier: Carrier
  city: String
  continentCode: String
  continentName: String
  count: String
  countryCode: String
  countryName: String
  currency: Currency
  emojiFlag: String
  emojiUnicode: String
  flag: String
  ip: String
  isEu: Boolean
  isBlocked: Boolean
  languages: [Language]
  latitude: String
  longitude: String
  organisation: String
  postal: String
  regionCode: String
  region: String
  success: Boolean!
  threat: Threat
  timeZone: TimeZone
}

type Market implements Node {
  id: ID!
  slug: String
  name: String
  currency: String!
  countries: [Country]
  latestTosVersion: Int!
  shippableCountries: [Country]
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
  usersCount: Int
  boxesCount: Int
  itemsCount: Int
  rouletteSummary(minDate: SequelizeDate, maxDate: SequelizeDate): MarketGameSummary
  crashSummary(minDate: SequelizeDate, maxDate: SequelizeDate): MarketGameSummary
  diceSummary(minDate: SequelizeDate, maxDate: SequelizeDate): MarketGameSummary
  matchBettingSummary(minDate: SequelizeDate, maxDate: SequelizeDate): MarketGameSummary
  pvpSummary(minDate: SequelizeDate, maxDate: SequelizeDate): MarketGameSummary
}

type MarketConnection {
  pageInfo: PageInfo!
  edges: [MarketEdge]
  total: Int
}

type MarketEdge {
  node: Market
  cursor: String!
}

type MarketGameSummary {
  amount: Float
  players: Int
  profit: Float
}

type CreateMarketPayload {
  market: Market
}

type UpdateMarketPayload {
  market: Market
}

type DeleteMarketPayload {
  market: Market
}

type CloneMarketPayload {
  market: Market
}

input CreateUpdateMarketInput {
  countries: [String]!
  currency: String!
  latestTosVersion: Int
  name: String!
  shippableCountries: [String]
  slug: String!
}

enum MarketOrderBy {
  ID
  ID_DESC
  NAME
  CREATED_AT
  CREATED_AT_DESC
}

type MatchBettingGameMeta {
  mapName: String
}

type MatchBettingGame implements Node {
  id: ID!
  provider: MatchBettingProvider!
  externalId: String
  beginAt: SequelizeDate
  complete: Boolean
  endAt: SequelizeDate
  draw: Boolean!
  finished: Boolean!
  forfeit: Boolean!
  length: Int
  match: MatchBettingMatch!
  matchId: ID!
  meta: MatchBettingGameMeta
  position: Int!
  status: MatchBettingGameStatus!
  videoGame: MatchBettingVideoGame!
  videoUrl: String @deprecated(reason: "Use 'streams' on match relation")
  winnerPlayer: MatchBettingPlayer
  winnerPlayerId: ID
  winnerTeam: MatchBettingTeam
  winnerTeamId: ID
  winnerType: MatchBettingOpponentType
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  markets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, marketIds: [ID!], statuses: [MatchBettingMarketStatus!], types: [MatchBettingMarketType!]): MatchBettingMarketConnection!
}

type MatchBettingGameConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingGameEdge]
  total: Int
}

type MatchBettingGameEdge {
  node: MatchBettingGame
  cursor: String!
}

type CreateMatchBettingGameSubscriptionPayload {
  matchBettingGame: MatchBettingGame!
}

type UpdateMatchBettingGameSubscriptionPayload {
  matchBettingGame: MatchBettingGame!
}

enum MatchBettingGameOrderBy {
  BEGIN_AT
  BEGIN_AT_DESC
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  POSITION
  POSITION_DESC
}

enum MatchBettingGameStatus {
  FINISHED
  NOT_PLAYED
  NOT_STARTED
  RUNNING
}

type MatchBettingLeague implements Node {
  id: ID!
  provider: MatchBettingProvider!
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  imageUrl: String
  name: String!
  url: String
  videoGame: MatchBettingVideoGame!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingLeagueConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingLeagueEdge]
  total: Int
}

type MatchBettingLeagueEdge {
  node: MatchBettingLeague
  cursor: String!
}

type CreateMatchBettingLeagueSubscriptionPayload {
  matchBettingLeague: MatchBettingLeague!
}

type UpdateMatchBettingLeagueSubscriptionPayload {
  matchBettingLeague: MatchBettingLeague!
}

enum MatchBettingLeagueOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingMarketSelectionResult {
  INVALID
  LOST
  WON
}

type MatchBettingMarketOddsUpdateSelection {
  odds: Float
  position: Int
  result: MatchBettingMarketSelectionResult
}

type MatchBettingMarketSelection {
  handicap: Float
  name: String!
  odds: Float
  participantPlayer: MatchBettingPlayer
  participantPlayerId: ID
  participantTeam: MatchBettingTeam
  participantTeamId: ID
  participantType: MatchBettingOpponentType
  position: Int
  result: MatchBettingMarketSelectionResult
  template: String!
}

type MatchBettingMarketOddsUpdate {
  gameId: ID
  marketId: ID!
  matchId: ID!
  selections: [MatchBettingMarketOddsUpdateSelection!]!
  status: MatchBettingMarketStatus!
}

type MatchBettingMarket implements Node {
  id: ID!
  provider: MatchBettingProvider!
  externalId: String
  game: MatchBettingGame
  gameId: ID
  lastRollbackAt: SequelizeDate
  match: MatchBettingMatch!
  matchId: ID!
  name: String!
  participantPlayer: MatchBettingPlayer
  participantPlayerId: ID
  participantTeam: MatchBettingTeam
  participantTeamId: ID
  participantType: MatchBettingOpponentType
  selections: [MatchBettingMarketSelection!]!
  status: MatchBettingMarketStatus!
  template: String!
  type: MatchBettingMarketType!
  videoGame: MatchBettingVideoGame!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingMarketConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingMarketEdge]
  total: Int
}

type MatchBettingMarketEdge {
  node: MatchBettingMarket
  cursor: String!
}

type ProcessMatchBettingMarketPayload {
  success: Boolean!
}

type CreateMatchBettingMarketSubscriptionPayload {
  matchBettingMarket: MatchBettingMarket!
}

type MatchBettingMarketOddsUpdatePayload {
  matchBettingMarketOddsUpdate: MatchBettingMarketOddsUpdate!
}

type UpdateMatchBettingMarketSubscriptionPayload {
  matchBettingMarket: MatchBettingMarket!
}

input ProcessMatchBettingMarketInput {
  isRollback: Boolean!
  matchBettingMarketId: ID!
  secret: String
}

enum MatchBettingMarketOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingMarketStatus {
  ACTIVE
  DEACTIVATED
  SETTLED
  SUSPENDED
}

enum MatchBettingMarketType {
  GAME
  MATCH
}

type MatchBettingMatchResult {
  opponentType: MatchBettingOpponentType!
  player: MatchBettingPlayer
  playerId: ID
  score: Int!
  team: MatchBettingTeam
  teamId: ID
}

enum MatchBettingMatchStatus {
  CANCELLED
  FINISHED
  LIVE
  NOT_BOOKED
  PENDING
  POSTPONED
  PRE_MATCH
  SETTLED
}

type MatchBettingMatchStream {
  embedUrl: String
  language: String!
  main: Boolean!
  official: Boolean!
  rawUrl: String
}

enum MatchBettingMatchType {
  BEST_OF
  CUSTOM
  FIRST_TO
  OW_BEST_OF
}

type MatchBettingMatch implements Node {
  id: ID!
  betsCount: Int
  provider: MatchBettingProvider!
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  beginAt: SequelizeDate
  draw: Boolean!
  endAt: SequelizeDate
  forfeit: Boolean!
  league: MatchBettingLeague!
  leagueId: ID!
  name: String!
  numberOfGames: Int!
  liveAvailable: Boolean!
  originalScheduledAt: SequelizeDate
  rescheduled: Boolean!
  results: [MatchBettingMatchResult!]!
  scheduledAt: SequelizeDate
  serie: MatchBettingSerie!
  serieId: ID!
  status: MatchBettingMatchStatus!
  streams: [MatchBettingMatchStream!]!
  totalBet: Float
  totalPayout: Float
  tournament: MatchBettingTournament!
  tournamentId: ID!
  type: MatchBettingMatchType!
  videoGame: MatchBettingVideoGame!
  winnerPlayer: MatchBettingPlayer
  winnerPlayerId: ID
  winnerTeam: MatchBettingTeam
  winnerTeamId: ID
  winnerType: MatchBettingOpponentType
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  games(after: String, first: PaginationAmount, before: String, last: PaginationAmount, gameIds: [ID!], statuses: [MatchBettingGameStatus!]): MatchBettingGameConnection!
  markets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, marketIds: [ID!], statuses: [MatchBettingMarketStatus!], types: [MatchBettingMarketType!]): MatchBettingMarketConnection!
}

type MatchBettingMatchConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingMatchEdge]
  total: Int
}

type MatchBettingMatchEdge {
  node: MatchBettingMatch
  cursor: String!
}

type CreateMatchBettingMatchFromProviderPayload {
  matchBettingMatches: [MatchBettingMatch!]!
}

type ProcessSettledMatchBettingMatchPayload {
  success: Boolean!
}

type RefreshMatchBettingMatchesStatsPayload {
  success: Boolean!
}

type ScheduleSyncForMatchBettingMatchesPayload {
  success: Boolean!
}

type SyncMatchBettingMatchesPayload {
  success: Boolean!
}

type CreateMatchBettingMatchSubscriptionPayload {
  matchBettingMatch: MatchBettingMatch!
}

type UpdateMatchBettingMatchSubscriptionPayload {
  matchBettingMatch: MatchBettingMatch!
}

input CreateMatchBettingMatchesFromProviderInput {
  externalIds: [String!]
  provider: MatchBettingProvider!
  scheduledAtFrom: SequelizeDate
  scheduledAtTo: SequelizeDate
}

input ProcessSettledMatchBettingMatchInput {
  matchBettingMatchId: ID!
  secret: String
}

input RefreshMatchBettingMatchesStatsInput {
  matchBettingMatchId: ID!
  secret: String
}

input ScheduleSyncForMatchBettingMatchesInput {
  matchBettingMatchIds: [ID!]!
  secret: String
}

input SyncMatchBettingMatchesInput {
  matchBettingMatchId: ID
  statuses: [MatchBettingMatchStatus!]
}

enum MatchBettingMatchOrderBy {
  BEGIN_AT
  BEGIN_AT_DESC
  BETS_COUNT
  BETS_COUNT_DESC
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  SCHEDULED_AT
  SCHEDULED_AT_DESC
  TOTAL_BET
  TOTAL_BET_DESC
  TOTAL_PROFIT
  TOTAL_PROFIT_DESC
}

enum MatchBettingOpponentType {
  PLAYER
  TEAM
}

type MatchBettingPlayer implements Node {
  id: ID!
  provider: MatchBettingProvider!
  externalId: String
  externalSlug: String
  firstName: String
  imageUrl: String
  lastName: String
  name: String!
  nationality: String
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingPlayerConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingPlayerEdge]
  total: Int
}

type MatchBettingPlayerEdge {
  node: MatchBettingPlayer
  cursor: String!
}

type CreateMatchBettingPlayerSubscriptionPayload {
  matchBettingPlayer: MatchBettingPlayer!
}

type UpdateMatchBettingPlayerSubscriptionPayload {
  matchBettingPlayer: MatchBettingPlayer!
}

enum MatchBettingPlayerOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingProvider {
  PANDA_SCORE
}

type GenerateMatchBettingReportPayload {
  fileName: String
  status: MatchBettingReportStatus!
}

input GenerateMatchBettingReportInput {
  createdAtMaxDate: SequelizeDate!
  createdAtMinDate: SequelizeDate!
  provider: MatchBettingProvider!
}

enum MatchBettingReportStatus {
  ERROR
  GENERATING
  NOTHING_TO_REPORT
}

type MatchBettingSerie implements Node {
  id: ID!
  provider: MatchBettingProvider!
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  beginAt: SequelizeDate!
  endAt: SequelizeDate
  fullName: String!
  league: MatchBettingLeague!
  leagueId: ID!
  name: String
  season: String
  tier: String @deprecated(reason: "Use 'tier' on tournament relation")
  videoGame: MatchBettingVideoGame!
  winnerPlayer: MatchBettingPlayer
  winnerPlayerId: ID
  winnerTeam: MatchBettingTeam
  winnerTeamId: ID
  winnerType: MatchBettingOpponentType
  year: Int!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingSerieConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingSerieEdge]
  total: Int
}

type MatchBettingSerieEdge {
  node: MatchBettingSerie
  cursor: String!
}

type CreateMatchBettingSerieSubscriptionPayload {
  matchBettingSerie: MatchBettingSerie!
}

type UpdateMatchBettingSerieSubscriptionPayload {
  matchBettingSerie: MatchBettingSerie!
}

enum MatchBettingSerieOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type MatchBettingSlipBetItem {
  currency: String!
  itemVariantId: ID!
  itemVariant: ItemVariant!
  userItemId: ID!
  userItem: UserItem!
  value: Float!
}

type MatchBettingSlipRollbackInfo {
  bigWin: Boolean!
  finishedAt: SequelizeDate
  status: MatchBettingSlipStatus!
  winRemainder: Float
  winUserItem: UserItem
  winUserItemId: ID
  winUserItemValue: Float
}

type MatchBettingSlipSelection {
  externalMarketId: String
  game: MatchBettingGame
  gameId: ID
  handicap: Float
  market: MatchBettingMarket!
  marketId: ID!
  marketName: String!
  marketSelectionName: String!
  marketSelectionPosition: Int
  match: MatchBettingMatch!
  matchId: ID!
  matchName: String!
  odds: Float!
  probabilityWithMargin: Float
  result: MatchBettingMarketSelectionResult
  tournament: MatchBettingTournament!
  tournamentId: ID!
  tournamentName: String!
}

type MatchBettingSlip implements Node {
  id: ID!
  provider: MatchBettingProvider!
  bet: Float!
  betItems: [MatchBettingSlipBetItem!]
  betItemsAmount: Float!
  bigWin: Boolean!
  currency: String!
  excluded: Boolean!
  finalOdds: Float!
  finishedAt: SequelizeDate
  payout: Float!
  payoutType: MatchBettingSlipPayoutType!
  rollback: Boolean!
  rollbackInfo: MatchBettingSlipRollbackInfo
  selections: [MatchBettingSlipSelection!]!
  status: MatchBettingSlipStatus!
  ticketsWon: Int!
  totalBet: Float!
  type: MatchBettingSlipType!
  user: User!
  userId: ID!
  winRemainder: Float
  winUserItem: UserItem
  winUserItemId: ID
  winUserItemValue: Float
  gameProviderFeePercent: Float
  affiliateUserId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  rakeback: Float
}

type MatchBettingSlipConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingSlipEdge]
  total: Int
}

type MatchBettingSlipEdge {
  node: MatchBettingSlip
  cursor: String!
}

type CompleteMatchBettingSlipPayload {
  success: Boolean!
}

type CreateMatchBettingSlipPayload {
  matchBettingSlip: MatchBettingSlip!
}

type UpdateMatchBettingSlipPayload {
  matchBettingSlip: MatchBettingSlip!
}

type CreateMatchBettingSlipSubscriptionPayload {
  matchBettingSlip: MatchBettingSlip!
}

type UpdateMatchBettingSlipSubscriptionPayload {
  matchBettingSlip: MatchBettingSlip!
}

input CompleteMatchBettingSlipInput {
  isRollback: Boolean!
  matchBettingSlipId: ID!
  secret: String
}

input CreateMatchBettingSlipInput {
  amount: Float!
  finalOdds: Float!
  payoutType: MatchBettingSlipPayoutType!
  selections: [MatchBettingSlipSelectionInput!]!
  type: MatchBettingSlipType!
  userItemIds: [ID!]!
}

input MatchBettingSlipSelectionInput {
  marketId: ID!
  odds: Float!
  position: Int!
}

input UpdateMatchBettingSlipInput {
  matchBettingSlipId: ID!
  status: MatchBettingSlipStatus!
}

enum MatchBettingSlipOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  PAYOUT_BASE
  PAYOUT_BASE_DESC
  TOTAL_BET_BASE
  TOTAL_BET_BASE_DESC
}

enum MatchBettingSlipPayoutType {
  COINS_ONLY
  ITEMS_AND_COINS
}

enum MatchBettingSlipStatus {
  ACTIVE
  LOST
  REFUNDED
  ROLLBACK
  WON
}

enum MatchBettingSlipType {
  MULTIPLE
  SINGLE
}

type MatchBettingTeam implements Node {
  id: ID!
  provider: MatchBettingProvider!
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  acronym: String
  imageUrl: String
  location: String
  name: String!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingTeamConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingTeamEdge]
  total: Int
}

type MatchBettingTeamEdge {
  node: MatchBettingTeam
  cursor: String!
}

type CreateMatchBettingTeamSubscriptionPayload {
  matchBettingTeam: MatchBettingTeam!
}

type UpdateMatchBettingTeamSubscriptionPayload {
  matchBettingTeam: MatchBettingTeam!
}

enum MatchBettingTeamOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type MatchBettingTournament implements Node {
  id: ID!
  provider: MatchBettingProvider!
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  beginAt: SequelizeDate
  endAt: SequelizeDate
  league: MatchBettingLeague!
  leagueId: ID!
  liveAvailable: Boolean!
  name: String!
  serie: MatchBettingSerie!
  serieId: ID!
  tier: String
  videoGame: MatchBettingVideoGame!
  winnerPlayer: MatchBettingPlayer
  winnerPlayerId: ID
  winnerTeam: MatchBettingTeam
  winnerTeamId: ID
  winnerType: MatchBettingOpponentType
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingTournamentConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingTournamentEdge]
  total: Int
}

type MatchBettingTournamentEdge {
  node: MatchBettingTournament
  cursor: String!
}

type CreateMatchBettingTournamentSubscriptionPayload {
  matchBettingTournament: MatchBettingTournament!
}

type UpdateMatchBettingTournamentSubscriptionPayload {
  matchBettingTournament: MatchBettingTournament!
}

enum MatchBettingTournamentOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingVideoGame {
  CALL_OF_DUTY
  CSGO
  DOTA2
  FIFA
  KING_OF_GLORY
  LOL
  LOL_WILD_RIFT
  OVERWATCH
  PUBG
  RAINBOW_SIX_SIEGE
  ROCKET_LEAGUE
  STAR_CRAFT_2
  STAR_CRAFT_BROOD_WAR
  VALORANT
}

type MatchBettingHeartBeat {
  at: SequelizeDate!
  provider: MatchBettingProvider!
}

type MatchBettingUpdateHeartBeatSubscriptionPayload {
  matchBettingHeartBeat: MatchBettingHeartBeat!
}

type MessageMeta {
  currency: String
  externalId: Int
  externalIdFull: ID
  externalModel: String
  name: String
  payoutCount: Int
  totalValue: Float
  userId: ID
  user: User
  giveawayId: ID
  giveaway: Giveaway
  userGiveawayIds: [ID!]
  userGiveaways: [UserGiveaway!]
  boxOpeningId: ID
  boxOpening: BoxOpening
  gemstoneBoostActivationId: ID
  gemstoneBoostActivation: GemstoneBoostActivation
  matchBettingSlipId: ID
  matchBettingSlip: MatchBettingSlip
  jackpotWinningTicketId: ID
  jackpotWinningTicket: JackpotWinningTicket
}

type Message implements Node {
  id: ID!
  channel: String
  body: String
  userId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  user: User
  meta: JSON
  meta2: MessageMeta @deprecated(reason: "Temporary while FE is being updated to change meta type")
  type: MessageType
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]
  total: Int
}

type MessageEdge {
  node: Message
  cursor: String!
}

type CreateMessagePayload {
  message: Message
}

type DeleteMessagesPayload {
  deletedAmount: Int
  messages: [Message]
}

type CreateMessageSubscriptionPayload {
  message: Message!
}

type DeleteMessageSubscriptionPayload {
  message: Message!
}

input CreateMessageInput {
  channel: MessageChannel!
  body: String!
}

input DeleteMessagesInput {
  id: ID
  userId: ID
}

enum MessageOrderBy {
  ID
  ID_DESC
}

enum MessageChannel {
  DE
  EN
  en
  HIGH_ROLLER
  PT
  SV
}

enum MessageType {
  BOX_OPENING
  GAME_JACKPOT_1X
  GAME_JACKPOT_2X
  GAME_JACKPOT_3X
  GEMSTONE_BOOST_ACTIVATION_CREATED
  GEMSTONE_BOX_WIN @deprecated(reason: "Use more general BOX_OPENING instead")
  GIVEAWAY_COMPLETED
  GIVEAWAY_CREATED
  GIVEAWAY_STARTED
  GIVEAWAY_WIN
  JACKPOT_TICKET_WIN
  MATCH_BETTING_SLIP_BIG_WIN
  PVP_BOX_GAME_BIG_WIN
}

type Note implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  body: String
  externalId: ID
  externalModel: ExternalModel
  external: SourceModels
  userId: ID
  user: User
  creatorId: ID
  creator: User
}

type NoteConnection {
  pageInfo: PageInfo!
  edges: [NoteEdge]
  total: Int
}

type NoteEdge {
  node: Note
  cursor: String!
}

type CreateNotePayload {
  note: Note
}

input CreateNoteInput {
  userId: ID!
  body: String!
}

enum ExternalModel {
  User
  WalletChange
}

enum NoteOrderBy {
  ID
  ID_DESC
}

type NotificationMessage implements Node {
  id: ID!
  notificationId: ID!
  notification: Notification!
  userId: ID!
  user: User!
  notificationOwnerId: ID!
  notificationOwner: User!
  content: String!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  readAt: SequelizeDate
  readById: ID
  readBy: User
}

type NotificationMessageConnection {
  pageInfo: PageInfo!
  edges: [NotificationMessageEdge]
  total: Int
}

type NotificationMessageEdge {
  node: NotificationMessage
  cursor: String!
}

type CreateNotificationMessagePayload {
  notificationMessage: NotificationMessage!
}

type MarkNotificationMessagesAsReadPayload {
  updatedCount: Int!
}

type CreateNotificationMessageSubscriptionPayload {
  notificationMessage: NotificationMessage!
}

type UpdateNotificationMessageSubscriptionPayload {
  notificationMessage: NotificationMessage!
}

input CreateNotificationMessageInput {
  content: String!
  notificationId: ID!
}

input MarkNotificationMessagesAsReadInput {
  ids: [ID!]!
}

enum NotificationMessageOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  READ_AT
}

type NotificationMeta {
  currency: String
  expiresAt: SequelizeDate
  itemVariantName: String
  name: String
  trackingUrl: String
  value: Float
}

type Notification implements Node {
  id: ID!
  userId: ID!
  user: User!
  type: NotificationType!
  creatorId: ID
  creator: User
  externalId: Int
  externalModel: String
  withMessages: Boolean!
  messages(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [NotificationMessageOrderBy], unreadOnly: Boolean): NotificationMessageConnection
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  readAt: SequelizeDate
  meta: JSON
  meta2: NotificationMeta @deprecated(reason: "Temporary while FE is being updated to change meta type")
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]
  total: Int
}

type NotificationEdge {
  node: Notification
  cursor: String!
}

type MarkNotificationsAsReadPayload {
  updatedCount: Int!
}

type CreateNotificationSubscriptionPayload {
  notification: Notification!
}

type UpdateNotificationSubscriptionPayload {
  notification: Notification!
}

input MarkNotificationsAsReadInput {
  ids: [ID!]!
}

enum NotificationOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  READ_AT
}

enum NotificationType {
  ORDER_CREATED
  ORDER_SHIPPED
  UPDATE_ITEM_VARIANTS_FAIL
  UPDATE_ITEM_VARIANTS_SUCCESS
  USER_ACHIEVEMENT_CREATED
  USER_ITEM_CANCELLED
  USER_ITEM_PROCESSING
  USER_ITEM_REQUESTED
}

type OrderNote implements Node {
  id: ID!
  body: String
  orderId: ID
  creatorId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  private: Boolean
  order: Order
  creator: User
}

type OrderNoteConnection {
  pageInfo: PageInfo!
  edges: [OrderNoteEdge]
  total: Int
}

type OrderNoteEdge {
  node: OrderNote
  cursor: String!
}

type CreateOrderNotePayload {
  orderNote: OrderNote
}

input CreateOrderNoteInput {
  orderId: ID!
  body: String!
  private: Boolean
}

enum OrderNoteOrderBy {
  ID
  ID_DESC
}

type Order implements Node {
  id: ID!
  trackingUrl: String
  screenshotUrl: String
  cost: Float!
  deliveryCost: Float!
  currency: String!
  userId: ID
  creatorId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  deliveryAt: SequelizeDate
  shippedAt: SequelizeDate
  user: User
  creator: User
  userItems(after: String, first: PaginationAmount, before: String, last: PaginationAmount): UserItemConnection!
  notes(after: String, first: PaginationAmount, before: String, last: PaginationAmount): OrderNoteConnection!
  zincOrder: ZincOrder
  createdInSeconds: Int
  estimatedDeliveryInDays: String
  estimatedDeliveryStrategy: OrderEstimatedDeliveryStrategy
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]
  total: Int
}

type OrderEdge {
  node: Order
  cursor: String!
}

type CreateOrderPayload {
  order: Order
}

type UpdateOrderPayload {
  order: Order
}

type DeleteOrderPayload {
  order: Order
}

type SendOrderDeliveredEmailPayload {
  order: Order
}

type CreateOrderSubscriptionPayload {
  order: Order!
}

type UpdateOrderSubscriptionPayload {
  order: Order!
}

type DeleteOrderSubscriptionPayload {
  order: Order!
}

type RetailerDeliveryStats {
  retailer: String
  retailerId: ID
  ordersCreatedInSecondsAvg: Int
  estimatedDeliveryInHours: Int
  fromRequestedToDeliveredInHours: Int
}

type RetailerDeliveryStatsResponse {
  stats: [RetailerDeliveryStats!]
}

input CreateOrderInput {
  cost: Float!
  deliveryCost: Float!
  userItemIds: [ID]!
  screenshotUrl: String
  secret: String
  trackingUrl: String
  estimatedDeliveryInDays: String
}

input UpdateOrderInput {
  orderId: ID!
  cost: Float!
  deliveryCost: Float!
  trackingUrl: String
  screenshotUrl: String!
  estimatedDeliveryInDays: String
}

input DeleteOrderInput {
  orderId: ID!
}

input SendOrderDeliveredEmailInput {
  orderId: ID!
  secret: String!
}

enum OrderOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  COST
  COST_DESC
}

enum OrderEstimatedDeliveryStrategy {
  AUTO
  MANUAL
}

type PaymentOptionProviderConfig {
  safeChargePaymentMethod: String
}

input PaymentOptionProviderConfigInput {
  safeChargePaymentMethod: String
}

type PaymentOption implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  canRefund: Boolean!
  confirmationsRequired: Int!
  transactionType: PaymentOptionTransactionType!
  type: String!
  providerName: String!
  provider: PaymentProvider!
  methodName: String
  method: PaymentMethod
  whitelistedCountries: [String!]!
  requiresEmail: Boolean!
  requiresProfile: Boolean!
  visible: Boolean!
  fraudCheckBefore: Boolean!
  fraudCheckAfter: Boolean!
  fixedFee: Float!
  percentageFee: Float!
  providerConfig: PaymentOptionProviderConfig
  minDepositAmount: Float! @deprecated(reason: "Use minAmount instead")
  maxDepositAmount: Float! @deprecated(reason: "Use maxAmount instead")
  minAmount: Float!
  maxAmount: Float!
  minExchangedAmount: Float! @deprecated(reason: "Use minAmount instead")
  maxExchangedAmount: Float! @deprecated(reason: "Use maxAmount instead")
  order: Int!
  approximateAmount: Boolean!
  bonusPercent: Float!
  bonusMaxAmount: Float
  action: PaymentOptionAction!
  iconUrl: String!
  enabled: Boolean!
  apm: PaymentOptionAPMType
  totalMaxAmount: Float
  totalMaxAmountDuration: Duration
  extraProcessingIfRiskScoreAtLeast: Float
}

type CreatePaymentOptionPayload {
  paymentOption: PaymentOption
}

type UpdatePaymentOptionPayload {
  paymentOption: PaymentOption
}

type DeletePaymentOptionPayload {
  paymentOption: PaymentOption
}

input CreatePaymentOptionInput {
  action: PaymentOptionAction!
  approximateAmount: Boolean!
  bonusMaxAmount: Float
  bonusPercent: Float!
  canRefund: Boolean!
  confirmationsRequired: Int
  enabled: Boolean!
  extraProcessingIfRiskScoreAtLeast: Float
  fixedFee: Float!
  fraudCheckAfter: Boolean!
  fraudCheckBefore: Boolean!
  iconUrl: String!
  maxAmount: Float!
  method: PaymentMethod
  methodName: String
  minAmount: Float!
  order: Int!
  percentageFee: Float!
  provider: PaymentProvider!
  providerConfig: PaymentOptionProviderConfigInput
  providerName: String!
  requiresEmail: Boolean
  requiresProfile: Boolean!
  totalMaxAmount: Float
  totalMaxAmountDuration: Duration
  transactionType: PaymentOptionTransactionType!
  type: String!
  visible: Boolean!
  whitelistedCountries: [String!]!
}

input DeletePaymentOptionInput {
  id: ID!
}

input UpdatePaymentOptionInput {
  action: PaymentOptionAction
  approximateAmount: Boolean
  bonusMaxAmount: Float
  bonusPercent: Float
  canRefund: Boolean
  confirmationsRequired: Int
  enabled: Boolean
  extraProcessingIfRiskScoreAtLeast: Float
  fixedFee: Float
  fraudCheckAfter: Boolean
  fraudCheckBefore: Boolean
  iconUrl: String
  id: ID!
  maxAmount: Float
  method: PaymentMethod
  methodName: String
  minAmount: Float
  order: Int
  percentageFee: Float
  provider: PaymentProvider
  providerConfig: PaymentOptionProviderConfigInput
  providerName: String
  requiresEmail: Boolean
  requiresProfile: Boolean
  totalMaxAmount: Float
  totalMaxAmountDuration: Duration
  transactionType: PaymentOptionTransactionType
  type: String
  visible: Boolean
  whitelistedCountries: [String!]
}

enum PaymentOptionAction {
  DEPOSIT
  WITHDRAWAL
}

enum PaymentOptionTransactionType {
  TRANSACTION
  CRYPTO_ADDRESS
}

enum PaymentMethod {
  ADA
  BCH
  BNB
  BNB_BSC
  BTC
  BTG
  BUSD
  DAI
  DASH
  DOGE
  ETC
  ETH
  EURS
  LTC
  NEO
  TRX
  USDC
  USDT
  USDTE
  USDTT
  XED
  XIN
  XRP
}

enum PaymentProvider {
  ALTERNATIVEPAYMENTS
  AMAZONPAY
  CHECKOUT
  COIN_GATE
  COINS_PAID
  CUBITS
  ECOPAYZ
  FONDY
  G2APAY
  IPS
  PAY_BEAR
  PAY_OP
  PAYSAFECARD
  SAFE_CHARGE
  STRIPE
  TAPM
  TRUST_PAYMENTS
  WONDERLAND_PAY
}

enum PaymentOptionAPMType {
  PAYPAL
  APPLE_PAY
}

type PlinkoBetItem {
  baseCurrency: String!
  currency: String!
  itemVariantId: ID!
  itemVariant: ItemVariant!
  userItemId: ID!
  userItem: UserItem!
  value: Float!
  valueBase: Float!
}

type PlinkoBetSlot {
  pins: Int!
  riskMode: PlinkoBetRiskMode!
  slotIndex: Int!
  slotMaxRoll: Int!
  slotMinRoll: Int!
  slotMultiplier: Float!
}

type PlinkoBetSlotsPayload {
  houseEdgePercent: Float
  pinsMax: Int!
  pinsMin: Int!
  slots: [PlinkoBetSlot!]!
}

type PlinkoBet implements Node {
  id: ID!
  currency: String!
  bet: Float!
  betItemsAmount: Float!
  totalBet: Float!
  betItems: [PlinkoBetItem!]
  pins: Int!
  houseEdgePercent: Float
  multipliers: [Float!]!
  payoutType: PlinkoBetPayoutType!
  riskMode: PlinkoBetRiskMode!
  payoutRemainder: Float!
  totalPayout: Float!
  userProfit: Float
  slot: PlinkoBetSlot!
  multiplier: Float!
  path: [PlinkoBetPath!]!
  winUserItemValue: Float
  userId: ID!
  user: User!
  rollId: ID!
  roll: Roll!
  winItemVariantId: Int
  winItemVariant: ItemVariant
  winUserItemId: Int
  winUserItem: UserItem
  pfVersion: ProvablyFairVersion!
  ticketsWon: Int!
  excluded: Boolean!
  bigWin: Boolean!
  gameProviderFeePercent: Float
  affiliateUserId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  rakeback: Float
}

type PlinkoBetConnection {
  pageInfo: PageInfo!
  edges: [PlinkoBetEdge]
  total: Int
}

type PlinkoBetEdge {
  node: PlinkoBet
  cursor: String!
}

type CreatePlinkoBetPayload {
  plinkoBet: PlinkoBet
}

type CreatePlinkoBetsPayload {
  plinkoBets: [PlinkoBet]
}

type CreatePlinkoBetSubscriptionPayload {
  plinkoBet: PlinkoBet!
}

input CreatePlinkoBetsInput {
  amount: Float!
  payoutType: PlinkoBetPayoutType!
  pins: Int!
  riskMode: PlinkoBetRiskMode!
  userItemIds: [ID!]!
  feVersion: Float
  numberOfBets: Int!
}

input CreatePlinkoBetInput {
  amount: Float!
  payoutType: PlinkoBetPayoutType!
  pins: Int!
  riskMode: PlinkoBetRiskMode!
  userItemIds: [ID!]!
  feVersion: Float
}

enum PlinkoBetOrderBy {
  ID
  ID_DESC
  MULTIPLIER
  MULTIPLIER_DESC
  TOTAL_BET
  TOTAL_BET_DESC
  TOTAL_PAYOUT
  TOTAL_PAYOUT_DESC
  USER_PROFIT
  USER_PROFIT_DESC
}

enum PlinkoBetRiskMode {
  HIGH
  LOW
  MEDIUM
}

enum PlinkoBetPayoutType {
  COINS_ONLY
  ITEMS_AND_COINS
}

enum PlinkoBetPath {
  LEFT
  RIGHT
}

type PollOption implements Node {
  id: ID!
  name: String!
  pollId: ID!
  poll: Poll!
  won: Boolean
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type PollOptionConnection {
  pageInfo: PageInfo!
  edges: [PollOptionEdge]
  total: Int
}

type PollOptionEdge {
  node: PollOption
  cursor: String!
}

type UpdatePollOptionPayload {
  pollOption: PollOption
}

type SelectPollOptionsPayload {
  poll: Poll
  pollOptions: [PollOption!]
  userPollOptions: [UserPollOption!]
}

input UpdatePollOptionInput {
  name: String
  pollOptionId: ID!
  won: Boolean
}

input SelectPollOptionsInput {
  pollId: ID!
  pollOptionIds: [ID!]!
}

enum PollOptionOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type PollResult {
  count: Int!
  pollOptionIds: [ID!]!
  pollOptions: [PollOption!]!
}

type PollUserRequirements {
  minLevel: Int
  maxLevel: Int
}

input PollUserRequirementsInput {
  minLevel: Int
  maxLevel: Int
}

type Poll implements Node {
  id: ID!
  name: String!
  description: String!
  status: PollStatus!
  startAt: SequelizeDate!
  endAt: SequelizeDate!
  minOptionsToSelect: Int!
  maxOptionsToSelect: Int!
  isMultiSelect: Boolean!
  isMutliSelect: Boolean! @deprecated(reason: "Use 'isMultiSelect', typo in old version")
  isActive: Boolean!
  totalVotes: Int! @deprecated(reason: "Use 'results' and sum counts")
  results: [PollResult!]
  userRequirements: PollUserRequirements
  correctAnswer: Boolean!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  pollOptions: PollOptionConnection!
}

type PollConnection {
  pageInfo: PageInfo!
  edges: [PollEdge]
  total: Int
}

type PollEdge {
  node: Poll
  cursor: String!
}

type UpdatePollPayload {
  poll: Poll
}

type CreatePollPayload {
  poll: Poll
  pollOptions: [PollOption!]
}

type UpdatePollStatusPayload {
  poll: Poll
}

type DeletePollPayload {
  poll: Poll
}

type ExportUserPollOptionsPayload {
  asset: Asset
}

type DeletePollSubscriptionPayload {
  pollId: ID
}

input CreatePollInputPollOptionInput {
  name: String!
}

input CreatePollInput {
  correctAnswer: Boolean!
  startIn: Duration
  startAt: SequelizeDate
  endAt: SequelizeDate
  endIn: Duration
  description: String!
  maxOptionsToSelect: Int
  minOptionsToSelect: Int
  name: String!
  userRequirements: PollUserRequirementsInput
  options: [CreatePollInputPollOptionInput!]!
}

input DeletePollInput {
  pollId: ID!
}

input ExportUserPollOptionsInput {
  pollId: ID!
}

input UpdatePollInput {
  correctAnswer: Boolean
  description: String
  endAt: SequelizeDate
  name: String
  pollId: ID!
  startAt: SequelizeDate
  userRequirements: PollUserRequirementsInput
}

input UpdatePollStatusInput {
  secret: String
  pollId: ID!
  status: PollStatus!
}

enum PollStatus {
  CANCELLED
  CREATED
  FINISHED
  STARTED
}

enum PollOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  END_AT
  END_AT_DESC
  ID
  ID_DESC
  START_AT
  START_AT_DESC
}

type PromoCode implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  code: String
  balance: Float!
  currency: String!
  walletType: WalletType
  amount: Int!
  maxBalance: Float!
  percentageReward: Float!
  redeemCount: Int!
  maxRedeemCount: Int
  minDepositRequirement: Float!
  expired: Boolean!
  type: PromoCodeType!
  itemVariantId: ID
  itemVariant: ItemVariant
  boxId: ID
  box: Box
  affiliateUserId: ID
  affiliateUser: User
  market: Market!
  marketId: ID!
  users: [User]
  giftCardOptionId: ID
  giftCardOption: GiftCardOption
}

type PromoCodeConnection {
  pageInfo: PageInfo!
  edges: [PromoCodeEdge]
  total: Int
}

type PromoCodeEdge {
  node: PromoCode
  cursor: String!
}

type PromoCodePayload {
  promoCode: PromoCode
}

type CreateAffiliatePromoCodePayload {
  promoCode: PromoCode
}

type UpdateAffiliatePromoCodePayload {
  promoCode: PromoCode
  id: ID!
}

type CreatePromoCodesPayload {
  affiliateUser: User
  affiliateUserId: ID
  amount: Int!
  balance: Float!
  box: Box
  boxId: ID
  codes: [String!]
  walletType: WalletType
  percentageReward: Float
  maxBalance: Float
  itemVariant: ItemVariant
  itemVariantId: ID
  marketId: ID!
  maxRedeemCount: Int
  minDepositRequirement: Float
  type: PromoCodeType!
}

type CreatePromoCodeSubscriptionPayload {
  promoCode: PromoCode!
}

type UsedPromoCodeSubscriptionPayload {
  createdAt: SequelizeDate!
  promoCode: PromoCode!
  user: User!
}

type UpdatePromoCodeSubscriptionPayload {
  promoCode: PromoCode!
}

type DeletePromoCodeSubscriptionPayload {
  promoCode: PromoCode!
}

type PromoCodeTimer {
  status: UserAffiliateStatus
  secondsLeft: Int
}

enum PromoCodeOrderBy {
  ID
  ID_DESC
  BALANCE_DESC
  BALANCE
  CREATED_AT_DESC
  CREATED_AT
  MAX_REDEEM_COUNT_DESC
  MAX_REDEEM_COUNT
  REDEEM_COUNT_DESC
  REDEEM_COUNT
}

input UsePromoCodeInput {
  code: String!
  recaptcha: String!
  seonSession: String
  visualRecaptcha: String
}

input DeletePromoCodeInput {
  id: ID!
}

input UpdatePromoCodeInput {
  affiliateUserId: ID
  amount: Int!
  balance: Float!
  boxId: ID
  code: String!
  walletType: WalletType
  id: ID!
  itemVariantId: ID
  maxBalance: Float
  maxRedeemCount: Int
  minDepositRequirement: Float
  percentageReward: Float
  type: PromoCodeType!
}

input CreateAffiliatePromoCodeInput {
  affiliateUserId: ID
  code: String!
  marketId: ID
}

input UpdateAffiliatePromoCodeInput {
  id: ID!
  code: String!
  affiliateUserId: ID
}

input CreatePromoCodeInput {
  affiliateUserId: ID
  amount: Int!
  balance: Float!
  boxId: ID
  codes: [String!]!
  walletType: WalletType
  itemVariantId: ID
  marketId: ID!
  maxBalance: Float!
  maxRedeemCount: Int
  minDepositRequirement: Float
  percentageReward: Float!
  type: PromoCodeType!
}

input CreateGiftCardPromoCodesInput {
  codes: [String!]!
  giftCardOptionId: ID!
}

enum PromoCodeType {
  GIFT_CARD
  PROMOTION
}

type Promotion {
  type: PromotionType!
  active: Boolean!
  starts: SequelizeDate
  ends: SequelizeDate
  boosts: [Boost!]!
  meta: PromotionMeta
}

type FullMoonPromotionMeta {
  fullMoonDates: [SequelizeDate!]!
}

type Boost {
  type: PromotionBoostType
  amount: Float
}

type PromotionMeta {
  fullMoonPromotion: FullMoonPromotionMeta
}

enum PromotionType {
  FULL_MOON
}

enum PromotionBoostType {
  RAKEBACK
  ADDITIONAL_REWARDS
}

enum ProvablyFairVersion {
  ALEA
  CRYPTO
  CRYPTO_V2
  CRYPTO_V3
}

type Proxy implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  uri: Url!
}

type ProxyConnection {
  pageInfo: PageInfo!
  edges: [ProxyEdge]
  total: Int
}

type ProxyEdge {
  node: Proxy
  cursor: String!
}

type CreateProxyPayload {
  proxy: Proxy!
}

type UpdateProxyPayload {
  proxy: Proxy!
}

type DeleteProxyPayload {
  proxy: Proxy!
}

input CreateProxyInput {
  uri: Url!
}

input DeleteProxyInput {
  id: ID!
}

input UpdateProxyInput {
  id: String!
  uri: Url!
}

enum ProxyOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type PvpBetBetItem {
  itemVariantId: ID!
  itemVariant: ItemVariant!
  userItemId: ID!
  userItem: UserItem!
  value: Float!
}

type PvpBetRollsHistoryItem {
  nonce: Int!
  pvpBetId: ID!
  pvpBet: PvpBet!
  pvpBetIdAsNumber: Int!
  rollId: ID!
  roll: Roll!
  rollNumber: Int!
  rollResult: String!
  status: PvpBetStatus!
}

enum PvpBetStatus {
  CREATED
  DRAW
  FINISHED
  LOST
  REFUNDED
  WAITING_FOR_GAME_END
  WON
}

type PvpBet implements Node {
  id: ID!
  betId: Int!
  pvpGameId: ID!
  pvpGame: PvpGame!
  pvpRoundId: ID!
  pvpRound: PvpRound!
  userId: ID!
  user: User!
  status: PvpBetStatus!
  gameType: PvpGameType!
  currency: String!
  houseEdgePercent: Float!
  bet: Float!
  betItemsAmount: Float!
  totalBet: Float!
  betItems: [PvpBetBetItem!]
  betRemainder: Float
  payout: Float
  houseEdge: Float
  winUserItemId: ID
  winUserItem: UserItem
  winUserItemValue: Float
  winRemainder: Float
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  finishedAt: SequelizeDate
  selection: Int
  serverSeedId: ID
  serverSeed: Seed
  rollId: ID
  roll: Roll
  rollResult: String
  rollNumber: Int!
  rollsHistory: [PvpBetRollsHistoryItem!]
  bigWin: Boolean!
  ticketsWon: Int!
  boxOpening: BoxOpening
  boxOpenings: [BoxOpening!] @deprecated(reason: "Each box opening has its own PvpBet use boxOpening field")
  byPvpBot: Boolean!
  winUserBoxId: ID
  winUserBox: UserBox
  teamSelection: Int
  boxId: ID
  box: Box
  gameProviderFeePercent: Float
  affiliateUserId: ID
}

type PvpBetConnection {
  pageInfo: PageInfo!
  edges: [PvpBetEdge]
  total: Int
}

type PvpBetEdge {
  node: PvpBet
  cursor: String!
}

type CreatePvpBetSubscriptionPayload {
  pvpBet: PvpBet!
}

type UpdatePvpBetSubscriptionPayload {
  pvpBet: PvpBet!
}

enum PvpBetOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type PvpBot implements Node {
  id: ID!
  status: PvpBotStatus!
  userId: ID!
  user: User!
  marketId: ID!
  market: Market!
  currency: String!
  displayName: String!
  minBetAmount: Float!
  maxBetAmount: Float!
  alertOnReserveUse: Boolean!
  remainingReserveUses: Int!
  reserveBalance: Float!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type PvpBotConnection {
  pageInfo: PageInfo!
  edges: [PvpBotEdge]
  total: Int
}

type PvpBotEdge {
  node: PvpBot
  cursor: String!
}

type CallPvpBotPayload {
  success: Boolean!
}

type CallPvpBotForRematchPayload {
  success: Boolean!
}

type CreatePvpBotPayload {
  pvpBot: PvpBot!
}

type UpdatePvpBotPayload {
  pvpBot: PvpBot!
}

type CreatePvpBotSubscriptionPayload {
  pvpBot: PvpBot!
}

type UpdatePvpBotSubscriptionPayload {
  pvpBot: PvpBot!
}

input CallPvpBotInput {
  pvpGameId: ID!
  teamSelection: Int
}

input CallPvpBotForRematchInput {
  pvpGameId: ID!
  secret: String
  userId: ID!
}

input CreatePvpBotInput {
  alertOnReserveUse: Boolean
  displayName: String!
  marketId: ID!
  maxBetAmount: Float!
  minBetAmount: Float!
  remainingReserveUses: Int!
  reserveBalance: Float!
  status: PvpBotStatus!
}

input UpdatePvpBotInput {
  data: UpdatePvpBotDataInput!
  pvpBotId: ID!
}

input UpdatePvpBotDataInput {
  alertOnReserveUse: Boolean
  displayName: String
  maxBetAmount: Float
  minBetAmount: Float
  remainingReserveUses: Int
  reserveBalance: Float
  status: PvpBotStatus
}

enum PvpBotOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum PvpBotStatus {
  DISABLED
  ENABLED
  SUSPENDED
}

type PvpDebugInfo {
  autoExit: Boolean
  createdByUserId: ID
  createdByUser: User
  exitedByUserId: ID
  exitedByUser: User
  playStartedByUserId: ID
  playStartedByUser: User
  staffExit: Boolean
}

type PvpGameActiveRound {
  id: ID!
  number: Int!
  round: PvpRound!
  status: PvpRoundStatus!
}

type PvpGamePlayer {
  exitedAt: SequelizeDate
  excluded: Boolean
  exiter: Boolean
  isPvpBot: Boolean!
  joinedAt: SequelizeDate
  status: PvpGamePlayerStatus!
  timesWon: Int
  totalBet: Float
  totalPayout: Float
  totalProfit: Float
  userId: ID!
  user: User!
  xpRewarded: BigInt
  teamSelection: Int
  winner: Boolean
  wonItemVariantIds: [ID!]
  wonItemVariants: [ItemVariant!]
  wonUserItemIds: [ID!]
  wonUserItems: [UserItem!]
  wonBalance: Float
}

enum PvpGamePlayerStatus {
  EXITED
  JOINED
}

enum PvpGameStrategy {
  HIGHEST_SUM
  LOWEST_SUM
}

enum PvpGameType {
  BOX
  COIN_FLIP
  DICE
}

type PvpGame implements Node {
  id: ID!
  userId: ID!
  user: User!
  status: PvpGameStatus!
  type: PvpGameType!
  currency: String!
  initialBet: Float!
  initialWinItemVariantId: ID
  initialWinItemVariant: ItemVariant
  initialWinItemVariantValue: Float
  houseEdgePercent: Float!
  totalBet: Float
  totalPayout: Float
  totalHouseEdge: Float
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  startedAt: SequelizeDate
  finishedAt: SequelizeDate
  players: [PvpGamePlayer!]!
  minPlayers: Int!
  maxPlayers: Int
  totalRoundCount: Int!
  totalBetCount: Int!
  activeRoundNumber: Int @deprecated(reason: "Use activeRound column instead")
  activeRound: PvpGameActiveRound
  rounds(after: String, first: PaginationAmount, before: String, last: PaginationAmount, pvpRoundId: ID, statuses: [PvpRoundStatus!]): PvpRoundConnection!
  bets(after: String, first: PaginationAmountLarge, before: String, last: PaginationAmountLarge, pvpBetId: ID, statuses: [PvpBetStatus!], userId: ID): PvpBetConnection!
  debugInfo: PvpDebugInfo
  serverSeedId: ID
  serverSeed: Seed
  clientSeedId: ID
  clientSeed: Seed
  blockNumber: String
  boxOpenings(after: String, first: PaginationAmount, before: String, last: PaginationAmount): BoxOpeningConnection
  strategy: PvpGameStrategy
  isPrivate: Boolean
  mode: PvpGameMode
  teams: [[PvpGamePlayer!]!]!
  maxNumberOfTeams: Int
  maxNumberOfPlayersInTeam: Int
  isMultiplierBoxGame: Boolean @deprecated(reason: "Use multiplierMode")
  multiplierMode: PvpGameMultiplierMode
  rakeback: Float
}

type PvpGameConnection {
  pageInfo: PageInfo!
  edges: [PvpGameEdge]
  total: Int
}

type PvpGameEdge {
  node: PvpGame
  cursor: String!
}

type CleanUpStalePvpGamesPayload {
  success: Boolean!
}

type CreatePvpGamePayload {
  pvpBet: PvpBet
  pvpBets: [PvpBet!]
  pvpGame: PvpGame!
  pvpRound: PvpRound
  pvpRounds: [PvpRound!]
}

type ExitPvpGamePayload {
  pvpGame: PvpGame!
}

type ExitAllActivePvpGamesPayload {
  pvpGames: [PvpGame]!
}

type FinishAllActivePvpGamesPayload {
  pvpGames: [PvpGame]!
}

type JoinPvpGamePayload {
  pvpBet: PvpBet
  pvpBets: [PvpBet!]
  pvpGame: PvpGame!
  pvpRound: PvpRound
  pvpRounds: [PvpRound!]
}

type PlayPvpGamePayload {
  pvpBets: [PvpBet!]!
  pvpGame: PvpGame!
  pvpRound: PvpRound
  pvpRounds: [PvpRound!]
  success: Boolean!
}

type RefundStuckPvpGameBetsPayload {
  alreadyRefundedPvpBets: [PvpBet!]!
  refundedPvpBets: [PvpBet!]!
}

type CreatePvpGameSubscriptionPayload {
  pvpGame: PvpGame!
}

type PlayPvpGameSubscriptionPayload {
  pvpGameId: ID!
  pvpRoundId: ID
}

type UpdatePvpGameSubscriptionPayload {
  pvpGame: PvpGame!
}

input CleanUpStalePvpGamesInput {
  lastRoundNumber: Int
  pvpGameId: ID
  secret: String!
}

input CreatePvpGameInput {
  amount: Float!
  boxes: [PvpGameBoxInput!]
  selection: Int
  strategy: PvpGameStrategy
  type: PvpGameType!
  userItemIds: [ID!]!
  isPrivate: Boolean
  mode: PvpGameMode
  numberOfPlayers: Int
  numberOfPlayersInTeam: Int
  numberOfTeams: Int
  teamSelection: Int
  autoJoinBots: Boolean
  multiplierMode: PvpGameMultiplierMode
}

input PvpGameBoxInput {
  boxId: ID!
  roundNumber: Int!
  multiplierBoxBet: Float
  amount: Int = 1
}

input ExitPvpGameInput {
  pvpGameId: ID!
}

input JoinPvpGameInput {
  pvpGameId: ID!
  selection: Int
  teamSelection: Int
}

input PlayPvpGameInput {
  pvpGameId: ID!
  secret: String
}

input RefundStuckPvpGameBetsInput {
  pvpGameId: ID!
}

enum PvpGameOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  FINISHED_AT
  FINISHED_AT_DESC
  ID
  ID_DESC
  INITIAL_BET
  INITIAL_BET_DESC
  TOTAL_BET
  TOTAL_BET_DESC
  TOTAL_PAYOUT
  TOTAL_PAYOUT_DESC
}

enum PvpGameStatus {
  CANCELLED
  CREATED
  STARTED
  FINISHED
}

enum PvpGameMode {
  SINGLE
  TEAM
}

enum PvpGameMultiplierMode {
  BOTS_ONLY
  PVP
}

type PvpRoundPlayer {
  excluded: Boolean
  exitedAt: SequelizeDate
  exiter: Boolean
  isPvpBot: Boolean!
  joinedAt: SequelizeDate
  payout: Float
  rolls: [PvpBetRollsHistoryItem!]
  status: PvpRoundPlayerStatus!
  totalGamePayout: Float
  userId: ID!
  user: User!
  winRemainder: Float
  winUserItemId: ID
  winUserItem: UserItem
}

enum PvpRoundPlayerStatus {
  DRAW
  EXITED
  JOINED
  LOST
  REFUNDED
  WAITING
  WON
}

type PvpRound implements Node {
  id: ID!
  roundId: Int!
  pvpGameId: ID!
  pvpGame: PvpGame!
  userId: ID!
  user: User!
  roundNumber: Int!
  status: PvpRoundStatus!
  hasDraws: Boolean!
  gameType: PvpGameType!
  currency: String!
  bet: Float!
  betChanged: Boolean!
  houseEdgePercent: Float!
  totalBet: Float
  totalPayout: Float
  totalHouseEdge: Float
  winItemVariantId: ID
  winItemVariant: ItemVariant
  winItemVariantValue: Float
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  startedAt: SequelizeDate
  finishedAt: SequelizeDate
  players: [PvpRoundPlayer!]!
  selections: JSON
  biggestWinValue: Float
  serverSeedId: ID
  serverSeed: Seed
  blockNumber: String
  rollId: ID
  roll: Roll
  rollResult: String
  totalBetCount: Int!
  bets(after: String, first: PaginationAmountLarge, before: String, last: PaginationAmountLarge, pvpBetId: ID, statuses: [PvpBetStatus!], userId: ID): PvpBetConnection!
  debugInfo: PvpDebugInfo
  boxId: ID
  box: Box
  numberOfBoxes: Int
  winBoxId: ID
  winBox: Box
  amountBetPerBox: Float
}

type PvpRoundConnection {
  pageInfo: PageInfo!
  edges: [PvpRoundEdge]
  total: Int
}

type PvpRoundEdge {
  node: PvpRound
  cursor: String!
}

type CreatePvpRoundPayload {
  pvpBet: PvpBet!
  pvpGame: PvpGame!
  pvpRound: PvpRound!
}

type CreatePvpRoundSubscriptionPayload {
  pvpRound: PvpRound!
}

type UpdatePvpRoundSubscriptionPayload {
  pvpRound: PvpRound!
}

input CreatePvpRoundInput {
  doubleBetAmount: Boolean!
  pvpGameId: ID!
  selection: Int
}

enum PvpRoundOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  ROUND_NUMBER
  ROUND_NUMBER_DESC
}

enum PvpRoundStatus {
  CANCELLED
  CREATED
  FINISHED
  STARTED
  WAITING_FOR_GAME_END
}

type RankUpGame implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  userId: ID!
  user: User!
  rakebackBet: Float!
  rakebackValue: Float!
  rakebackValueCurrency: String
  startTierRank: Int!
  startUserTier: UserTier!
  destinationTierRank: Int!
  destinationUserTier: UserTier!
  chance: Float!
  win: Boolean!
  rollId: ID!
  roll: Roll!
}

type RankUpGameEdge {
  cursor: String!
  node: RankUpGame
}

type RankUpGameConnection {
  pageInfo: PageInfo!
  edges: [RankUpGameEdge]
  total: Int
}

input CreateRankUpGameInput {
  rakebackBet: Float!
  destinationTierRank: Int!
}

enum RankUpGameOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

"""An integer between 1 and 250"""
scalar PaginationAmount

"""An integer between 1 and 800"""
scalar PaginationAmountLarge

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type ResetPasswordPayload {
  success: Boolean!
  user: User
}

input ResetPasswordInput {
  hash: String!
  password: String!
  confirmPassword: String!
  recaptcha: String!
  twoFactorToken: String
  visualRecaptcha: String
}

type RetailerType implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  code: String!
  name: String!
}

type RetailerConnection {
  pageInfo: PageInfo!
  edges: [RetailerEdge]
  total: Int
}

type RetailerEdge {
  node: RetailerType
  cursor: String!
}

type RetailerPayload {
  retailer: RetailerType!
}

input CreateRetailerInput {
  code: String!
  name: String!
}

input DeleteRetailerInput {
  retailerId: ID!
}

input UpdateRetailerInput {
  code: String!
  name: String!
  retailerId: ID!
}

enum RetailerOrderBy {
  ID
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

type Roll implements Node {
  id: ID!
  userId: ID
  user: User
  serverSeedId: ID
  serverSeed: Seed
  clientSeedId: ID
  clientSeed: Seed
  game: GameType
  nonce: Int
  value: Int
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type RollConnection {
  pageInfo: PageInfo!
  edges: [RollEdge]
  total: Int
}

type RollEdge {
  node: Roll
  cursor: String!
}

type CreateRollSubscriptionPayload {
  roll: Roll!
}

enum RollOrderBy {
  ID
  ID_DESC
  DESC
}

type RollHistory {
  id: ID!
  maxId: ID!
  minId: ID!
  serverSeedId: ID
  clientSeedId: ID
  minNonce: Int
  maxNonce: Int
  game: GameType
  serverSeed: Seed
  clientSeed: Seed
  createdAt: SequelizeDate
  createdAtDate: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""Decimal value with a maximum of 2 decimal digits."""
scalar Decimal

"""
A special custom Scalar type for Dates that converts to a ISO formatted string 
"""
scalar SequelizeDate

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values. BigInt can represent values between -(2^53) + 1 and 2^53 - 1. 
"""
scalar BigInt

"""The `Upload` scalar type represents a file upload."""
scalar Upload

scalar Url

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

type CommitVersion {
  sha: String
  shortSha: String
  tag: String
}

type Seed implements Node {
  id: ID!
  userId: ID!
  type: SeedType
  value: String
  hash: String
  future: Boolean
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  user: User
}

type SeedConnection {
  pageInfo: PageInfo!
  edges: [SeedEdge]
  total: Int
}

type SeedEdge {
  node: Seed
  cursor: String!
}

type ChangeSeedPayload {
  seed: Seed!
  seeds: [Seed!]!
}

input ChangeSeedInput {
  type: SeedType!
  value: String
}

enum SeedOrderBy {
  ID
  ID_DESC
}

enum SeedType {
  SERVER
  CLIENT
}

type Setting implements Node {
  id: ID!
  key: String!
  description: String
  value: String
  type: SettingType!
  visibleByRoles: [UserRole!]
  editableByRoles: [UserRole!]
}

type UpdateSettingPayload {
  setting: Setting
}

type FlushSettingCachePayload {
  settings: [Setting]
}

type UpdateSettingSubscriptionPayload {
  setting: Setting!
}

input UpdateSettingInput {
  id: ID
  jsonSchema: String
  key: String
  value: String!
}

input FlushSettingInput {
  unused: Boolean
}

enum SettingType {
  BOOLEAN
  FLOAT
  INTEGER
  JSON
  STRING
  TEXT
}

type ShipTo {
  address1: String!
  address2: String
  city: String!
  country: String!
  lastName: String!
  name: String!
  phone: String!
  postcode: String!
  region: String
}

type SocialStory implements Node {
  """The ID of an object"""
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  url: String!
  oEmbedData: SocialStoryOEmbedData!
  position: Int!
  provider: SocialStoryProvider!
}

type SocialStoryEdge {
  node: SocialStory!
  cursor: String!
}

type SocialStoryOEmbedData {
  html: String!
}

type SocialStoryConnection {
  pageInfo: PageInfo!
  edges: [SocialStoryEdge!]!
  total: Int
}

type CreateSocialStoryPayload {
  socialStory: SocialStory!
}

type UpdateSocialStoryPayload {
  socialStory: SocialStory!
}

type DeleteSocialStoryPayload {
  deleted: Boolean!
}

input CreateSocialStoryInput {
  url: String
  position: Int = 0
}

input UpdateSocialStoryInput {
  id: ID!
  position: Int
  url: String
}

input DeleteSocialStoryInput {
  id: ID!
}

enum SocialStoryOrderBy {
  POSITION
  POSITION_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum SocialStoryProvider {
  TWITTER
  FACEBOOK
  INSTAGRAM
}

"""
Will provide oEmbed data with selected theme if url provider supports it
"""
enum SocialStoryTheme {
  LIGHT
  DARK
}

type SourceModels {
  bet: Bet
  box: Box
  boxOpening: BoxOpening
  crashBet: CrashBet
  diceBet: DiceBet
  exchange: Exchange
  gemstoneGame: GemstoneGame
  matchBettingSlip: MatchBettingSlip
  plinkoBet: PlinkoBet
  promoCode: PromoCode
  pvpBet: PvpBet
  pvpGame: PvpGame
  rankUpGame: RankUpGame
  trade: Trade
  transaction: Transaction
  user: User
  userItem: UserItem
  userTierAsset: UserTierAsset
  walletChange: WalletChange
}

type SteamAsset implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  lockExpiresAt: SequelizeDate
  itemVariantId: ID
  itemVariant: ItemVariant
  steamBotId: ID
  steamBot: SteamBot
  incomingSteamOfferId: ID
  incomingSteamOffer: SteamOffer
  outgoingSteamOfferId: ID
  outgoingSteamOffer: SteamOffer
  appId: String
  contextId: String
  assetId: String
  classId: String
  instanceId: String
  iconUrl: String
  inspectLink: String
  marketHashName: String
  depositValue: Float
  withdrawValue: Float
  currency: String!
}

type SteamAssetConnection {
  pageInfo: PageInfo!
  edges: [SteamAssetEdge]
  total: Int
}

type SteamAssetEdge {
  node: SteamAsset
  cursor: String!
}

type BanSteamBotAssetsPayload {
  success: Boolean!
}

type UpdateAvailableAssetsPayload {
  success: Boolean!
}

type CreateSteamAssetSubscriptionPayload {
  steamAsset: SteamAsset!
}

type UpdateSteamAssetSubscriptionPayload {
  steamAsset: SteamAsset!
}

type DeleteSteamAssetSubscriptionPayload {
  steamAsset: SteamAsset!
}

input BanSteamBotAssetsInput {
  steamBotId: ID!
}

input UpdateAvailableAssetsInput {
  itemIds: [ID!]!
}

enum SteamAssetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DEPOSIT_VALUE
  DEPOSIT_VALUE_DESC
  LOCK_EXPIRES_AT
  LOCK_EXPIRES_AT_DESC
}

type SteamBot implements Node {
  id: ID!
  username: String
  steamTradeUrl: String
  displayName: String!
  steamId: String
  country: String
  deposit: Boolean
  withdraw: Boolean
  enabled: Boolean
  activeAt: SequelizeDate
  activeUntil: SequelizeDate
  inventorySeenAt: SequelizeDate
  lastKnownHost: String
  banned: Boolean
  steamAccountPassword: String
  steamAccountLoginKey: String
  steamAccountSharedSecret: String
  steamAccountIdentitySecret: String
  steamGame: Int
  httpProxy: String
  httpsProxy: String
  minAcceptableTradeValue: Float
  maxAcceptableTradeValue: Float
  maxStockValue: Float
  maxStockCount: Int
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  steamAssets(after: String, first: PaginationAmount, before: String, last: PaginationAmount): SteamAssetConnection
  steamAssetValue: Float
  userId: ID
  user: User
  type: SteamBotType!
}

type SteamBotConnection {
  pageInfo: PageInfo!
  edges: [SteamBotEdge]
  total: Int
}

type SteamBotEdge {
  node: SteamBot
  cursor: String!
}

type CheckSteamBotActivityPlayload {
  success: Boolean!
}

type CreateSteamBotPayload {
  steamBot: SteamBot
}

type CreateSteamBotsPayload {
  steamBots: [SteamBot!]!
  total: Int
}

type UpdateSteamBotPayload {
  steamBot: SteamBot
}

type DeleteSteamBotPayload {
  steamBot: SteamBot
}

type WakeUpSteamBotPayload {
  steamBot: SteamBot
}

type SleepSteamBotPayload {
  steamBot: SteamBot
}

type CreateSteamBotSubscriptionPayload {
  steamBot: SteamBot!
}

type UpdateSteamBotSubscriptionPayload {
  steamBot: SteamBot!
}

type DeleteSteamBotSubscriptionPayload {
  steamBot: SteamBot!
}

input CheckSteamBotActivityInput {
  secret: String!
}

input CreateUpdateSteamBotInput {
  steamId: String!
  username: String!
  displayName: String!
  type: SteamBotType
  steamTradeUrl: String
  active: Boolean
  deposit: Boolean
  withdraw: Boolean
  enabled: Boolean
  banned: Boolean
  steamAccountPassword: String
  steamAccountLoginKey: String
  steamAccountSharedSecret: String
  steamAccountIdentitySecret: String
  httpProxy: String
  httpsProxy: String
  minAcceptableTradeValue: Float
  maxAcceptableTradeValue: Float
  maxStockValue: Float
  maxStockCount: Int
  steamGame: Int
}

enum SteamBotOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum SteamBotType {
  INFO
  TRADE
}

type SteamOfferItemVariant implements Node {
  id: ID!
  steamOfferId: ID
  steamOffer: SteamOffer
  itemVariantId: ID
  itemVariant: ItemVariant
  direction: OfferDirection
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
}

type SteamOfferItemVariantConnection {
  pageInfo: PageInfo!
  edges: [SteamOfferItemVariantEdge]
  total: Int
}

type SteamOfferItemVariantEdge {
  node: SteamOfferItemVariant
  cursor: String!
}

enum SteamOfferItemVariantOrderBy {
  ID
  ID_DESC
}

enum OfferDirection {
  GIVE
  TAKE
}

type SteamOffer implements Node {
  id: ID!
  state: SteamOfferState
  steamBotId: ID
  steamBot: SteamBot
  steamTradeUrl: String
  userId: ID
  user: User
  userItem: UserItem
  steamOfferItemVariants: SteamOfferItemVariantConnection
  outgoingSteamAssets: SteamAssetConnection
  tradeOfferId: String
  availableAt: SequelizeDate!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  expiresAt: SequelizeDate
  trade: Trade
}

type SteamOfferConnection {
  pageInfo: PageInfo!
  edges: [SteamOfferEdge]
  total: Int
}

type SteamOfferEdge {
  node: SteamOffer
  cursor: String!
}

type DeleteSteamOfferPayload {
  steamOffer: SteamOffer
}

type ReadySteamOfferPayload {
  steamOffer: SteamOffer
}

type CreateSteamOffersPayload {
  steamOffers: [SteamOffer]
}

type CreateSteamOfferSubscriptionPayload {
  steamOffer: SteamOffer!
}

type UpdateSteamOfferSubscriptionPayload {
  steamOffer: SteamOffer!
}

type DeleteSteamOfferSubscriptionPayload {
  steamOffer: SteamOffer!
}

input ReadySteamOfferInput {
  steamOfferId: ID
  tradeId: ID
}

input CreateSteamOffersInput {
  steamAssetIds: [ID!]
  steamTradeUrl: ID
  userId: ID
}

enum SteamOfferOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  EXPIRES_AT
  EXPIRES_AT_DESC
  AVAILABLE_AT
  AVAILABLE_AT_DESC
}

enum SteamOfferState {
  ACCEPTED
  ACTIVE
  CANCELED_BY_SECOND_FACTOR
  CANCELED
  COUNTERED
  CREATED_NEEDS_CONFIRMATION
  DECLINED
  EXPIRED
  IN_ESCROW
  INVALID_ITEMS
  INVALID
  PROCESSING
}

type UpdateSteamStatusPayload {
  status: String!
}

type SteamUserTradeHistory {
  steamTrades: [SteamTradeFromHistory!]!
}

type SteamTradeFromHistory {
  tradeid: String!
  steamid_other: String!
  time_init: Int!
  status: Int!
  amountOfAssetsGiven: JSON
  amountOfAssetsReceived: JSON
}

input UpdateSteamStatusInput {
  addTask: Boolean
  secret: String
}

enum SteamAppName {
  CSGO
  DOTA2
  H1Z1
  PUBG
  RUST
  STEAM
}

type CreateSupportTicketPayload {
  status: String!
  message: String!
}

input CreateSupportTicketInput {
  email: String!
  supportMessage: String!
}

type Tag implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  name: String!
  visible: Boolean!
  boxes: [Box]
  position: Int!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]
  total: Int
}

type TagEdge {
  node: Tag
  cursor: String!
}

type CreateTagPayload {
  tag: Tag
}

type UpdateTagPayload {
  tag: Tag
}

type DeleteTagPayload {
  tag: Tag
}

type CreateTagSubscriptionPayload {
  tag: Tag!
}

type UpdateTagSubscriptionPayload {
  tag: Tag!
}

type DeleteTagSubscriptionPayload {
  tag: Tag!
}

input CreateTagInput {
  name: String!
  visible: Boolean!
  position: Int
}

input UpdateTagInput {
  id: ID!
  name: String!
  visible: Boolean!
  position: Int
}

input DeleteTagInput {
  id: ID!
}

enum TagOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  POSITION
  POSITION_DESC
}

type PurgeTaskQueuePayload {
  success: Boolean!
}

input PurgeTaskQueueInput {
  name: String!
}

type Team implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  name: String!
  totalGemstones(createdAtMinDate: SequelizeDate!, createdAtMaxDate: SequelizeDate!): Float!
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]
  total: Int
}

type TeamEdge {
  node: Team
  cursor: String!
}

enum TeamOrderBy {
  ID
  ID_DESC
}

type Ticket implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  jackpotId: ID
  jackpot: Jackpot
  userId: ID!
  user: User!
  teamId: ID
  sequentialNumber: Int
}

type TicketConnection {
  pageInfo: PageInfo!
  edges: [TicketEdge]
  total: Int
}

type TicketEdge {
  node: Ticket
  cursor: String!
}

type CreateTicketSubscriptionPayload {
  ticket: Ticket!
}

type CreateTicketsPayload {
  tickets: [Ticket!]!
}

input CreateTicketsInput {
  amountOfTicketsToGive: Int
  jackpotId: ID!
  secret: String!
  userId: ID!
}

enum TicketOrderBy {
  ID
  ID_DESC
}

type TileOpening implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  currency: String!
  currencyBase: String!
  rewardAmount: Float!
  rewardAmountBase: Float!
  tileSetting: TileSetting
  tileSettingId: ID
  userId: ID!
  user: User
}

type TileOpeningConnection {
  pageInfo: PageInfo!
  edges: [TileOpeningEdge]
  total: Int
}

type TileOpeningEdge {
  node: TileOpening
  cursor: String!
}

type GetTileOpeningRewardAmountPayload {
  rewardAmount: Float!
  rewardAmountBase: Float!
}

type OpenTilePayload {
  tileOpening: TileOpening!
}

enum TileOpeningOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type TileSetting implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  claimableTiles: Int!
  levelRequired: Int!
  market: Market
  marketId: ID
  minRewardPerTile: Float!
  minRewardPerTileInUserCurrency: Float!
}

type TileSettingConnection {
  pageInfo: PageInfo!
  edges: [TileSettingEdge]
  total: Int
}

type TileSettingEdge {
  node: TileSetting
  cursor: String!
}

type TileSettingPayload {
  tileSetting: TileSetting!
}

input CreateTileSettingInput {
  claimableTiles: Int!
  levelRequired: Int!
  marketId: ID
  minRewardPerTile: Float!
}

input DeleteTileSettingInput {
  tileSettingId: ID!
}

input UpdateTileSettingInput {
  claimableTiles: Int!
  levelRequired: Int!
  marketId: ID
  minRewardPerTile: Float!
  tileSettingId: ID!
}

enum TileSettingOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type TradeItem implements Node {
  id: ID!
  tradeId: ID!
  trade: Trade!
  marketName: String!
  value: Float!
  customValue: Boolean!
  currency: String!
  itemVariantId: ID!
  itemVariant: ItemVariant
  markupPercent: Float!
}

type TradeItemConnection {
  pageInfo: PageInfo!
  edges: [TradeItemEdge]
  total: Int
}

type TradeItemEdge {
  node: TradeItem
  cursor: String!
}

enum TradeItemOrderBy {
  ID
  ID_DESC
}

type Trade implements Node {
  id: ID!
  status: TradeStatus!
  cancelReason: CancelReason
  depositorUserId: ID
  depositor: User
  withdrawerUserId: ID
  withdrawer: User
  totalValue: Float!
  customValue: Boolean!
  currency: String!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  expiresAt: SequelizeDate
  suspectedTraderCanJoinAfter: SequelizeDate!
  canJoinAfter: SequelizeDate
  steamOfferId: ID
  steamOffer: SteamOffer
  steamAppId: String
  steamAppName: SteamAppName
  depositorSentItemsAt: SequelizeDate
  withdrawerReceivedItemsAt: SequelizeDate
  joinedAt: SequelizeDate
  processingAt: SequelizeDate
  cooldownAt: SequelizeDate
  finishedAt: SequelizeDate
  storageUnitLastModificationAt: SequelizeDate
  tradeItems: [TradeItem]
  withdrawerSteamTradeUrl: String
  type: TradeType
  promoCodeId: ID
  promoCode: PromoCode
  trackingType: TradeTrackingType
  steamTradeOfferId: String
  markupPercent: Float!
}

type TradeConnection {
  pageInfo: PageInfo!
  edges: [TradeEdge]
  total: Int
}

type TradeEdge {
  node: Trade
  cursor: String!
}

type CreateTradePayload {
  trade: Trade!
}

type CreateTradesPayload {
  trades: [Trade]!
}

type JoinTradesPayload {
  trades: [Trade]!
}

type AutoJoinTradePayload {
  trade: Trade
}

type ProcessTradePayload {
  trade: Trade!
}

type CancelTradePayload {
  trade: Trade!
}

type CompleteTradePayload {
  trade: Trade!
}

type TrackTradePayload {
  success: Boolean!
}

type CleanUpTradesPayload {
  success: Boolean!
}

type CleanUpCooldownTradesPayload {
  success: Boolean!
}

type CreateTradeSubscriptionPayload {
  trade: Trade!
}

type GenerateTradesCsvPayload {
  fileName: String!
}

type UpdateTradeSubscriptionPayload {
  trade: Trade!
}

type UpdateTradesMarkupPayload {
  trades: [Trade!]!
}

type RemoveFromListedTradeSubscriptionPayload {
  tradeId: ID!
}

input AutoJoinTradeInput {
  tradeId: ID!
  secret: String
}

input CreateTradeInput {
  tradeItems: [TradeItemInput!]!
  recaptcha: String!
  visualRecaptcha: String
  promoCode: String
}

input CreateTradesInput {
  promoCode: String
  recaptcha: String!
  tradeItemsList: [[TradeItemInput!]!]!
  visualRecaptcha: String
}

input GenerateTradesCsvInput {
  after: String
  first: PaginationAmount
  before: String
  last: PaginationAmount
  orderBy: [TradeOrderBy]
  tradeId: ID
  userId: ID
  depositorSteamId: String
  withdrawerSteamId: String
  steamAppName: SteamAppName
  status: TradeStatus
  minTotalValue: Float
  maxTotalValue: Float
  marketName: String
  statuses: [TradeStatus!]
  updatedAtMinDate: SequelizeDate
  updatedAtMaxDate: SequelizeDate
  maxMarkupPercent: Float
  bySupplier: Boolean
}

input TradeItemInput {
  itemVariantId: ID!
  value: Float
}

input JoinTradesInput {
  tradeIds: [ID!]!
  recaptcha: String!
  visualRecaptcha: String
}

input ProcessTradeInput {
  tradeId: ID!
}

input CancelTradeInput {
  tradeId: ID!
}

input CompleteTradeInput {
  tradeId: ID!
}

input TrackTradeInput {
  tradeId: ID!
  payload: JSON!
  secret: String!
}

input CleanUpTradesInput {
  secret: String!
}

input CleanUpCooldownTradesInput {
  secret: String!
}

input UpdateTradesMarkupInput {
  itemVariantIds: [ID!]!
  secret: String
}

enum TradeOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  BEST_DEALS
  MARKUP_PERCENT
  MARKUP_PERCENT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  TOTAL_VALUE
  TOTAL_VALUE_DESC
}

enum TradeStatus {
  CANCELLED
  COMPLETED
  COMPLETED_PRIVATE
  COMPLETED_WITH_STORAGE_UNIT
  FROZEN
  JOINED
  LISTED
  PROCESSING
  COOLDOWN
}

enum CancelReason {
  EXPIRED
  NO_CONFIRMATION
  REVOKED_API_KEY
  USER_CANCELLED
}

enum TradeType {
  TRADER
  WAX_PEER
}

enum TradeTrackingType {
  API_KEY_DEPOSITOR
  API_KEY_WITHDRAWER
  INVENTORY
  STEAM_OFFER
}

type TransactionUserBox {
  box: Box!
  boxId: ID!
  userBox: UserBox!
  userBoxId: ID!
}

type TransactionUserItem {
  itemVariant: ItemVariant
  itemVariantId: ID
  userItem: UserItem
  userItemId: ID
}

type TransactionMeta {
  apmExternalEmail: String
  apmTransactionId: String
  minimumExchangedAmount: Float
  originalAmount: Float
  originalExchangedAmount: Float
  originalExchangeRate: Float
  externalTransactionIds: [String]
  withdrawalApprovedByUserId: ID
  withdrawalApprovedByUser: User
}

type Transaction implements Node {
  id: ID!
  amount: Decimal!
  amountBase: Float
  currency: String!
  currencyBase: String
  type: TransactionType!
  status: TransactionStatus!
  externalId: String
  promoCodeId: ID
  promoCode: PromoCode
  provider: PaymentProvider
  method: PaymentMethod
  url: String
  exchangedAmount: Float
  exchangeRate: Float
  cryptoAddress: String
  ipAddress: String
  userId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  renderData: JSON
  meta: TransactionMeta
  user: User
  paymentOptionId: ID
  paymentOption: PaymentOption
  bonusPercent: Float!
  bonusMaxAmount: Float
  bonusAmount: Float!
  feeAmount: Float!
  userBoxes: [TransactionUserBox!]
  userItems: [TransactionUserItem]
  userCurrency: String
  userCurrencyAmount: Float
  riskScore: Float
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]
  total: Int
}

type TransactionEdge {
  node: Transaction
  cursor: String!
}

type ApproveWithdrawalTransactionPayload {
  transaction: Transaction
}

type CreateTransactionPayload {
  transaction: Transaction
}

type GenerateTransactionsCsvPayload {
  fileName: String!
}

type MigrateTransactionsPayload {
  success: Boolean!
}

type UpdateTransactionPayload {
  transaction: Transaction
}

type CreateTransactionSubscriptionPayload {
  transaction: Transaction!
}

type UpdateTransactionSubscriptionPayload {
  transaction: Transaction!
}

input CreateTransactionInput {
  amount: Float!
  cryptoAddress: String
  paymentOptionId: ID!
  preferredCurrency: String
  promoCode: String
  seonSession: String
  sourceCurrency: String
  token: String
  twoFactorToken: String
  userItemIds: [ID!]
  userBoxIds: [ID!]
  type: TransactionType
  provider: PaymentProvider
  method: PaymentMethod
  recaptcha: String
  visualRecaptcha: String
}

input GenerateTransactionsCsvInput {
  after: String
  before: String
  first: PaginationAmount
  last: PaginationAmount
  orderBy: [TransactionOrderBy]
  createdAfter: String @deprecated(reason: "Use 'minDate'")
  createdBefore: String @deprecated(reason: "Use 'maxDate'")
  minDate: String
  maxDate: String
  promoCodeId: ID
  provider: PaymentProvider
  providers: [PaymentProvider!]
  status: String @deprecated(reason: "Use 'statuses'")
  statuses: [TransactionStatus!]
  types: [TransactionType!]
  transactionId: ID
  userId: ID
  externalIds: [String!]
}

input MigrateTransactionsInput {
  secret: String
}

input UpdateTransactionInput {
  transactionId: ID!
  status: TransactionStatus!
}

input ApproveWithdrawalTransactionInput {
  approved: Boolean!
  transactionId: ID!
}

enum TransactionOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  AMOUNT
  AMOUNT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
}

enum TransactionStatus {
  CANCELED
  COMPLETED
  FAILED
  PENDING
  PENDING_APPROVAL
  PRE_APPROVAL
  STARTED
}

type Trigger implements Node {
  id: ID!
  status: TriggerStatus!
  valueType: TriggerValueType!
  gameTypes: [GameType!]
  startAt: SequelizeDate!
  endAt: SequelizeDate!
  isEnabled: Boolean!
  minValue: Float!
  currentValue: Float
  triggerValue: Float
  totalValue: Float
  progress: Float!
  currency: String!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  createGiveawayData: JSON
}

type TriggerConnection {
  pageInfo: PageInfo!
  edges: [TriggerEdge]
  total: Int
}

type TriggerEdge {
  node: Trigger
  cursor: String!
}

type CreateTriggerPayload {
  trigger: Trigger
}

type UpdateTriggerPayload {
  trigger: Trigger
}

input CreateTriggerInput {
  createGiveawayInput: CreateGiveawayInput
  currency: String!
  endAt: SequelizeDate
  gameTypes: [GameType!]
  minValue: Float
  startAt: SequelizeDate
  triggerValue: Float!
  valueType: TriggerValueType
}

input UpdateTriggerStatusInput {
  scheduleAt: SequelizeDate
  secret: String
  status: TriggerStatus!
  triggerId: ID!
}

input UpdateTriggerInput {
  createGiveawayInput: CreateGiveawayInput
  endAt: SequelizeDate
  gameTypes: [GameType!]
  minValue: Float
  secret: String
  startAt: SequelizeDate
  triggerId: ID!
  triggerValue: Float
}

enum TriggerStatus {
  DISABLED
  ENABLED
}

enum TriggerValueType {
  DEPOSIT
  WAGER
}

enum TriggerOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  END_AT
  END_AT_DESC
  ID
  ID_DESC
  START_AT
  START_AT_DESC
}

type UserAchievement implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  userId: ID!
  user: User!
  achievementId: ID!
  achievement: Achievement!
  claimedAt: SequelizeDate
  bonusAmount: Float @deprecated(reason: "Use rewards instead")
  rewards: [AchievementReward!]!
  xpAmount: Int @deprecated(reason: "Use rewards instead")
  bonusExpiresAt: SequelizeDate @deprecated(reason: "Use rewardsExpireAt instead")
  rewardsExpireAt: SequelizeDate
  type: AchievementType
  source: SourceModels!
  sourceId: Int
  sourceModel: String
}

type UserAchievementConnection {
  pageInfo: PageInfo!
  edges: [UserAchievementEdge]
  total: Int
}

type UserAchievementEdge {
  node: UserAchievement
  cursor: String!
}

type ClaimUserAchievementPayload {
  userAchievement: UserAchievement!
}

type CreateUserAchievementPayload {
  userAchievement: UserAchievement!
}

type TriggerUserAchievementPayload {
  success: Boolean
}

type FlushUserAchievementCachePayload {
  userAchievementIds: [ID]
}

type CreateUserAchievementSubscriptionPayload {
  userAchievement: UserAchievement!
}

type UpdateUserAchievementSubscriptionPayload {
  userAchievement: UserAchievement!
}

input ClaimUserAchievementInput {
  userAchievementId: ID!
}

input CreateUserAchievementInput {
  achievementId: ID!
  userId: ID!
}

input TriggerUserAchievementInput {
  achievementType: AchievementType!
  secret: String!
  triggerData: TriggerDataInput!
}

input TriggerDataInput {
  ancestorBoxId: ID
  amount: Float
  channel: String
  contents: String
  currency: String
  externalId: String!
  gameType: GameType
  minPayoutValue: Float
  payoutItemVariantId: ID
  rouletteBetMode: BetMode
  rouletteSelections: [Int]
  userId: ID!
  userItemUsed: Boolean
}

input FlushUserAchievementCacheInput {
  userId: ID!
}

enum UserAchievementOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type UserAddress implements Node {
  address1: String!
  address2: String
  alias: String
  city: String!
  country: Country!
  createdAt: SequelizeDate!
  default: Boolean!
  id: ID!
  lastName: String!
  name: String!
  phone: String!
  postcode: String!
  region: String!
  updatedAt: SequelizeDate!
  user: User
  userId: ID!
}

type UserAddressConnection {
  pageInfo: PageInfo!
  edges: [UserAddressEdge]
  total: Int
}

type UserAddressEdge {
  node: UserAddress
  cursor: String!
}

type UserAddressPayload {
  userAddress: UserAddress!
}

input CreateUserAddressInput {
  address1: String!
  address2: String
  alias: String
  city: String!
  country: String!
  default: Boolean
  lastName: String!
  name: String!
  phone: String!
  postcode: String!
  region: String!
  userId: ID
}

input DeleteUserAddressInput {
  userAddressId: ID!
}

input UpdateUserAddressInput {
  address1: String!
  address2: String
  alias: String
  city: String!
  country: String!
  default: Boolean
  lastName: String!
  name: String!
  phone: String!
  postcode: String!
  region: String!
  userAddressId: ID!
}

enum UserAddressOrderBy {
  ID
  ID_DESC
}

type UserAsset implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  userId: ID!
  user: User!
  consumedRakebackValue: Float!
  userTierAssetId: ID!
  userTierAsset: UserTierAsset
  assetRankAtBuy: Int
}

type UserAssetConnection {
  pageInfo: PageInfo!
  edges: [UserAssetEdge]
  total: Int
}

type UserAssetEdge {
  node: UserAsset
  cursor: String!
}

type CreateUserAssetSubscriptionPayload {
  userAsset: UserAsset!
}

input SetUserAvatarInput {
  userAssetId: ID!
}

enum UserAssetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type UserBox implements Node {
  id: ID!
  status: UserBoxStatus!
  acquiredValue: Float!
  consumedValue: Float
  refundedValue: Float
  refundValue: Float
  refundValueInUserCurrency: Float
  currency: String!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  consumedAt: SequelizeDate
  refundedAt: SequelizeDate
  userId: ID!
  user: User!
  boxId: ID!
  box: Box!
  ancestorBoxId: ID
  ancestorBox: Box
  pvpGameId: ID
  pvpGame: PvpGame
  pvpBetId: ID
  pvpBet: PvpBet
}

type UserBoxConnection {
  pageInfo: PageInfo!
  edges: [UserBoxEdge]
  total: Int
}

type UserBoxEdge {
  node: UserBox
  cursor: String!
}

type PurchaseBoxPayload {
  box: Box
  userBoxes: [UserBox]
}

type RefundUserBoxPayload {
  userBox: UserBox
}

type CreateUserBoxSubscriptionPayload {
  userBox: UserBox!
}

type UpdateUserBoxSubscriptionPayload {
  userBox: UserBox!
}

input PurchaseBoxInput {
  boxId: ID!
  amount: Int
  multiplierBoxBet: Float
}

input RefundUserBoxInput {
  id: ID!
}

enum UserBoxOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  VALUE
  VALUE_DESC
}

enum UserBoxStatus {
  AVAILABLE
  CONSUMED
  REFUNDED
}

type UserCommunication implements Node {
  id: ID!
  userId: ID!
  user: User!
  mutedUserId: ID!
  mutedUser: User!
}

type UserCommunicationConnection {
  edges: [UserCommunicationEdge]
  total: Int
}

type UserCommunicationEdge {
  node: UserCommunication
  cursor: String!
}

type CreateUserCommunicationPayload {
  userCommunication: UserCommunication!
}

type DeleteUserCommunicationPayload {
  userCommunication: UserCommunication!
}

type CreateUserCommunicationSubscriptionPayload {
  userCommunication: UserCommunication!
}

type DeleteUserCommunicationSubscriptionPayload {
  userCommunication: UserCommunication!
}

input CreateUserCommunicationInput {
  mutedUserId: ID!
}

input DeleteUserCommunicationInput {
  userCommunicationId: ID!
}

enum UserCommunicationOrderBy {
  ID
  ID_DESC
}

type GenerateUserDepositWithdrawalCsvPayload {
  fileName: String
}

input GenerateUserDepositWithdrawalCsvInput {
  orderBy: UserDepositWithdrawalReportOrderBy!
  sources: [UserDepositWithdrawalReportSource!]!
  types: [UserDepositWithdrawalReportTransactionType!]!
  userId: ID!
}

enum UserDepositWithdrawalReportOrderBy {
  UPDATED_AT
  UPDATED_AT_DESC
  VALUE
  VALUE_DESC
}

enum UserDepositWithdrawalReportSource {
  TRADE
  TRANSACTION
  USER_ITEM
  WAX_PEER_TRADE
}

enum UserDepositWithdrawalReportTransactionType {
  DEPOSIT
  WITHDRAWAL
}

type UserGiveaway implements Node {
  id: ID!
  giveawayId: ID!
  giveaway: Giveaway!
  userId: ID!
  user: User!
  rewardAmount: Float!
  won: Boolean!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type UserGiveawayConnection {
  pageInfo: PageInfo!
  edges: [UserGiveawayEdge]
  total: Int
}

type UserGiveawayEdge {
  node: UserGiveaway
  cursor: String!
}

type CreateUserGiveawayPayload {
  userGiveaway: UserGiveaway
}

type UpdateUserGiveawayPayload {
  userGiveaway: UserGiveaway
}

enum UserGiveawayOrderBy {
  ID
  ID_DESC
}

type UserInviteCode implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  userId: ID!
  user: User
  inviteCodeId: ID!
  inviteCode: InviteCode!
}

type UserItemMeta {
  userIsPvpBot: Boolean
}

type UserItem implements Node {
  id: ID!
  status: UserItemStatus!
  acquiredValue: Float!
  consumedValue: Float
  consumeValue: Float!
  consumeValueInUserCurrency: Float
  currentValue: Float
  currency: String!
  userId: ID!
  itemVariantId: ID!
  orderId: ID!
  steamOfferId: ID
  consumedAt: SequelizeDate
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  requestedAt: SequelizeDate
  processingAt: SequelizeDate
  orderedAt: SequelizeDate
  comment: String
  processor: User
  user: User
  itemVariant: ItemVariant!
  steamOffer: SteamOffer
  order: Order
  zincOrder: ZincOrder
  shipTo: ShipTo
  meta: UserItemMeta
  source: SourceModels!
  sourceModel: String
  sourceId: ID
}

type UserItemConnection {
  pageInfo: PageInfo!
  edges: [UserItemEdge]
  total: Int
}

type UserItemEdge {
  node: UserItem
  cursor: String!
}

type CheckUserItemStatusPayload {
  userItem: UserItem!
  userItems: [UserItem!]!
}

type UpdateUserItemPayload {
  userItem: UserItem!
}

type CreateUserItemSubscriptionPayload {
  source: UserItemSource
  userItem: UserItem!
}

type UpdateUserItemSubscriptionPayload {
  userItem: UserItem!
}

type DeleteUserItemSubscriptionPayload {
  userItem: UserItem!
}

input CheckUserItemStatusInput {
  userItemId: [ID!]!
  secret: String!
}

input UpdateUserItemInput {
  userItemId: ID!
  status: UserItemStatus!
  comment: String
}

input UpdateUserItemShipToInput {
  shipTo: ShipToInput!
  userItemId: ID!
}

input ShipToInput {
  address1: String!
  address2: String
  city: String!
  country: String!
  lastName: String!
  name: String!
  phone: String!
  postcode: String!
  region: String
}

enum UserItemOrderBy {
  ID
  ID_DESC
  CONSUMED_AT
  CONSUMED_AT_DESC
  CONSUMED_VALUE
  CONSUMED_VALUE_DESC
  CREATED_AT
  CREATED_AT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  VALUE
  VALUE_DESC
}

enum UserItemStatus {
  AVAILABLE
  CONSUMED
  EXCHANGED
  LOCKED
  LOCKED_UNTIL_EXTERNAL_PROVIDER_CALLBACK
  ORDERED
  PVP_TEAM_WIN_AUTO_CONSUMED
  PROCESSING
  RECEIVED
  REQUESTED
}

enum UserItemSource {
  BOX_OPENING
  CRASH_WIN
  DICE_BET
  JACKPOT
  MATCH_BETTING_WIN
  PLINKO_WIN
  PROMO_CODE
  PVP_BOX_OPENING
  PVP_WIN
  PVP_WIN_TEAM_DISTRIBUTION
  WALLET
}

type UserPollOption implements Node {
  id: ID!
  pollId: ID!
  poll: Poll!
  pollOptionId: ID!
  pollOption: PollOption!
  userId: ID
  user: User
  createdAt: SequelizeDate!
}

type CreateUserPollOptionsPayload {
  userPollOptions: [UserPollOption!]
}

type UserPollOptionConnection {
  pageInfo: PageInfo!
  edges: [UserPollOptionEdge]
  total: Int
}

type UserPollOptionEdge {
  node: UserPollOption
  cursor: String!
}

enum UserPollOptionOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type UserPreferences implements Node {
  id: ID!
  name: String
  lastName: String
  address1: String
  address2: String
  postcode: String
  region: String
  city: String
  country: Country
  birthDate: SequelizeDate
  gender: Gender
  phone: String
  userId: ID!
  user: User
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  hideSteamProfile: Boolean
  hideProfileStats: Boolean
}

type UpdateUserPreferencesPayload {
  userPreferences: UserPreferences
}

input UpdateUserPreferencesInput {
  userId: ID!
  name: String
  lastName: String
  address1: String
  address2: String
  postcode: String
  region: String
  city: String
  country: String
  gender: Gender
  birthDate: SequelizeDate
  phone: String
  hideSteamProfile: Boolean
  hideProfileStats: Boolean
}

enum Gender {
  MALE
  FEMALE
}

type UserProgressChange implements Node {
  createdAt: SequelizeDate!
  externalId: ID!
  id: ID!
  source: UserProgressSource!
  updatedAt: SequelizeDate!
  user: User!
  userId: ID!
  valueAfter: Int!
  valueChange: Int!
}

type UserProgressChangeConnection {
  edges: [UserProgressChangeEdge]
  pageInfo: PageInfo!
  total: Int
}

type UserProgressChangeEdge {
  cursor: String!
  index: Int
  node: UserProgressChange
}

type UserProgressChangesSummaryConnection {
  edges: [UserProgressChangesSummaryEdge]
  pageInfo: PageInfo!
  total: Int
}

type UserProgressChangesSummaryEdge {
  cursor: String!
  node: UserProgressChangesSummary
}

type UserProgressChangesSummary {
  deposits: Float!
  games: Float!
  misc: Float!
  userId: ID!
}

enum UserProgressSource {
  ACHIEVEMENT_CLAIM
  ALTERATION
  BOX_PURCHASE
  CRASH_BET
  DICE_BET
  GAME_BET
  ITEM_SELL
  MATCH_BETTING_SLIP_BET
  PLINKO_BET
  PVP_BET
  PVP_BOX_GAME_BET
  XP_PURCHASE
}

enum UserProgressChangeOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum UserProgressChangeSummaryOrderBy {
  DEPOSITS
  DEPOSITS_DESC
  GAMES
  GAMES_DESC
  MISC
  MISC_DESC
}

type UserProgress implements Node {
  id: ID!
  createdAt: SequelizeDate!
  changes(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [UserProgressChangeOrderBy]): UserProgressChangeConnection
  updatedAt: SequelizeDate!
  userId: ID!
  user: User!
  xp: BigInt!
  xpMultiplier: Float!
  level: Int!
  requiredXp(level: Int): BigInt
  nextRequiredXp: BigInt
}

type UpdateUserProgressSubscriptionPayload {
  source: UserProgressSource
  userProgress: UserProgress!
}

type PurchaseXpPayload {
  xpAmount: Int!
  cost: Float!
  currency: String!
  userProgress: UserProgress!
  userProgressChanges: [UserProgressChange!]!
}

input PurchaseXpInput {
  xpAmount: Int!
  currency: String
}

type UserPromoCodeMeta {
  balance: Float!
  currency: String!
}

type UserPromoCode {
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  meta: [UserPromoCodeMeta!]
  promoCodeId: ID!
  promoCode: PromoCode!
  userId: ID!
  user: User!
}

type UserPromoCodeConnection {
  pageInfo: PageInfo!
  edges: [UserPromoCodeEdge]
  total: Int
}

type UserPromoCodeEdge {
  node: UserPromoCode
  cursor: String!
}

enum UserPromoCodeOrderBy {
  CREATED_AT
  CREATED_AT_DESC
}

type UserRequirements {
  mustBeInTeam: Boolean
}

type UserStat implements Node {
  id: ID!
  userId: ID
  user: User
  marketId: ID!
  market: Market
  excluded: Boolean!
  stat: UserStatStat!
  type: UserStatType!
  dateFrom: SequelizeDate
  dateTo: SequelizeDate
  value: Float!
  currency: String!
  externalId: String
  externalModel: SourceModels!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type UserStatConnection {
  pageInfo: PageInfo!
  edges: [UserStatEdge]
  total: Int
}

type UserStatEdge {
  node: UserStat
  cursor: String!
}

enum UserStatOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DATE_FROM
  DATE_FROM_DESC
  VALUE
  VALUE_DESC
}

enum UserStatStat {
  HIGHEST_BET
  HIGHEST_BET_LOSS
  HIGHEST_CRASH_MULTIPLIER
  HIGHEST_CRASH_WIN
  HIGHEST_ROULETTE_GREEN_WIN
  HIGHEST_ROULETTE_WIN
  HIGHEST_UNBOXING_WIN
  TOTAL_BOXES_OPENED
  TOTAL_COMMISSION
  TOTAL_COMMISSION_EARNT
  TOTAL_DEPOSITED
  TOTAL_PROFIT
  TOTAL_PROFIT_DAILY_FREE
  TOTAL_PROFIT_GAME_JACKPOT
  TOTAL_WAGERED
  TOTAL_WAGERED_CRASH
  TOTAL_WAGERED_DICE
  TOTAL_WAGERED_MATCH_BETTING
  TOTAL_WAGERED_PLINKO
  TOTAL_WAGERED_PVP
  TOTAL_WAGERED_ROULETTE
  TOTAL_WAGERED_UNBOXING
  TOTAL_WITHDRAWN
}

enum UserStatType {
  ALL_TIME
  DAILY
  WEEKLY
}

type UserTierAsset implements Node {
  asset: Asset
  assetId: ID!
  createdAt: SequelizeDate!
  enabled: Boolean!
  id: ID!
  name: String
  rakebackPrice: Float!
  updatedAt: SequelizeDate!
  userTier: UserTier
  userTierId: ID!
}

type UserTierAssetConnection {
  pageInfo: PageInfo!
  edges: [UserTierAssetEdge]
  total: Int
}

type UserTierAssetEdge {
  node: UserTierAsset
  cursor: String!
}

type CreateUserTierAssetSubscriptionPayload {
  userTierAsset: UserTierAsset!
}

type UpdateUserTierAssetSubscriptionPayload {
  userTierAsset: UserTierAsset!
}

type DeleteUserTierAssetSubscriptionPayload {
  userTierAsset: UserTierAsset!
}

type ClaimUserTierAssetSubscriptionPayload {
  userAsset: UserAsset!
}

type GetUserTierAssetsStatusesPayload {
  canClaim: Boolean
  userTierAsset: UserTierAsset
}

input CreateUserTierAssetInput {
  assetId: ID!
  enabled: Boolean
  name: String
  rakebackPrice: Float!
  rank: Int
}

input UpdateUserTierAssetInput {
  addToRank: Int
  assetId: ID
  enabled: Boolean
  id: ID!
  name: String
  rakebackPrice: Float
  removeFromRank: Int
  userTierId: ID
}

enum UserTierAssetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type UserTier implements Node {
  arPercentage: Float
  asset: Asset
  assetId: ID
  createdAt: SequelizeDate
  id: ID!
  name: String
  rakeback: Float
  ggr: Float
  rakebackBetAmountForInstantRankUp: Float
  rank: Int
  rankUpChance(rakebackBet: Float): Float
  rewards: [UserTierReward!]
  updatedAt: SequelizeDate
  userCount: Int
  userTierAssets: [UserTierAsset!]
  node: UserTier
  cursor: String!
}

type UserTierEdge {
  cursor: String!
  node: UserTier
}

type UserTierConnection {
  pageInfo: PageInfo!
  edges: [UserTierEdge]
  total: Int
}

input UpdateUserTierInput {
  assetId: ID
  ggr: Float
  id: ID!
  name: String
  rakeback: Float
  rank: Int
  arPercentage: Float
  rewards: [ArAchievementInput!]
}

input ArAchievementInput {
  type: UserTierRewardType
  rewardPercentage: Float
}

type UserTierReward {
  type: UserTierRewardType
  rewardPercentage: Float
}

enum UserTierRewardType {
  DAILY
  WEEKLY
  MONTHLY
}

enum UserTierOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  RANK
  RANK_DESC
}

type UserTwoFactorBackupCode {
  code: String!
  createdAt: SequelizeDate!
  deletedAt: SequelizeDate
  updatedAt: SequelizeDate!
}

type DailyWithdrawalRemainder {
  amount: Float!
  canRequest: Boolean!
  hasPendingRequest: Boolean!
  isRestricted: Boolean!
}

type UserMeta {
  isPvpBot: Boolean
}

type User implements Node {
  acceptTos: Boolean
  achievements(after: String, first: PaginationAmount, before: String, last: PaginationAmount): AchievementConnection!
  affiliate: User
  affiliatedUsers(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [UserOrderBy]): UserConnection!
  affiliatePromoCodes: [PromoCode!]!
  affiliateTierId: ID
  affiliateTier: AffiliateTier
  affiliateUserId: ID
  authentic: Boolean
  avatar: String
  avatarOriginal: String
  bannedUntil: SequelizeDate
  banReason: String
  createdAt: SequelizeDate!
  cryptoAddresses: CryptoAddressConnection!
  currency: String!
  customAffiliateId: String
  customTitle: String
  customTitleColor: String
  dailyConsecutiveActiveCount: Int!
  dailyWithdrawalRemainder: DailyWithdrawalRemainder
  dailyWithdrawLimit: Float
  deletedAt: SequelizeDate
  displayName: String
  documents(after: String, first: PaginationAmount, before: String, last: PaginationAmount): DocumentConnection!
  email: String
  emailToVerify: String
  forceBlankAvatar: Boolean
  hideSteamProfile: Boolean
  id: ID!
  initialAffiliate: User
  lastActiveAt: SequelizeDate
  lastDepositAt: SequelizeDate
  lastPaypalDepositAt: SequelizeDate
  level: Int @deprecated(reason: "Use userProgress level instead")
  marketId: ID
  market: Market
  marketingEmails: Boolean!
  matchBettingBannedUntil: SequelizeDate
  matchBettingBanReason: String
  matchBettingMaximumTotalBetAmount: Float
  messages(after: String, first: PaginationAmount, before: String, last: PaginationAmount): MessageConnection!
  meta: UserMeta
  microphoneEnabled: Boolean!
  mutedUntil: SequelizeDate
  name: String
  notifications(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [NotificationOrderBy], unreadOnly: Boolean): NotificationConnection!
  online: Boolean
  openId: String
  orders(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [OrderOrderBy]): OrderConnection!
  permissions: Int
  preferences: UserPreferences
  rank: Int
  referralPromoCodeId: ID
  referralPromoCode: PromoCode
  roles: [UserRole]
  seeds(after: String, first: PaginationAmount, before: String, last: PaginationAmount): SeedConnection!
  steamApiKey: String
  steamBot: SteamBot
  steamDisplayName: String
  steamId: String
  steamTradeUrl: String
  stickyReferee: Boolean!
  supplier: Boolean!
  suspectedTrader: Boolean!
  tags: [Tag!]
  teamId: ID
  team: Team
  tickets(after: String, first: PaginationAmount, before: String, last: PaginationAmount, jackpotId: ID): TicketConnection!
  tier: UserTier
  totalClaimedAr: Float
  totalClaimedRakeback: Float
  totalCommissionEarnt: Decimal
  totalDeposit: Decimal
  totalDepositOfReferredUsers: Decimal
  totalDepositorsReferred: Int
  totalRakeback: Float
  totalReferredDepositValue: Decimal
  totalUserItemValue(status: [UserItemStatus!]): Float
  totalUsersReferred: Int
  totalWithdraw: Decimal
  totalWithdrawOfReferredUsers: Decimal
  tradeBannedSource: UserTradeBannedType
  tradeBannedUntil: SequelizeDate
  tradeBanReason: String
  trader: Boolean!
  transactions(after: String, first: PaginationAmount, before: String, last: PaginationAmount): TransactionConnection!
  twitterId: String
  totpTwoFactorEnabled: Boolean
  unlockedChat: Boolean
  updatedAt: SequelizeDate!
  userItems(after: String, before: String, first: PaginationAmount, last: PaginationAmount, status: [UserItemStatus!]): UserItemConnection!
  userProgress: UserProgress
  verificationStatus: VerificationStatus
  verified: Boolean
  walletChanges(after: String, before: String, first: PaginationAmount, last: PaginationAmount, orderBy: [WalletChangeOrderBy]): WalletChangeConnection!
  wallets(after: String, first: PaginationAmount, before: String, last: PaginationAmount): [Wallet]
  withdrawalRestrictions: UserWithdrawalRestrictions
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]
  total: Int
}

type UserEdge {
  node: User
  cursor: String!
  index: Int
}

type DisableTotpTwoFactorAuthenticationPayload {
  success: Boolean!
}

type EnableTotpTwoFactorAuthenticationPayload {
  backupCodes: [UserTwoFactorBackupCode!]
  valid: Boolean!
}

type GenerateNewTotpTwoFactorBackupCodesPayload {
  backupCodes: [UserTwoFactorBackupCode!]!
}

type GenerateTotpTwoFactorAuthenticationSecretPayload {
  secret: String!
}

type InvalidateAllUserSessionsPayload {
  success: Boolean!
}

type UpdateUserPayload {
  user: User
}

type UpdateUserEmailPayload {
  user: User
}

type RetrieveTotpTwoFactorBackupCodesPayload {
  backupCodes: [UserTwoFactorBackupCode!]!
}

type RevertUserPayload {
  user: User
}

type AcceptTosPayload {
  acceptedTosVersion: Int!
  acceptTos: Boolean!
}

type LoginPayload {
  user: User
}

type UpdateSuspectedTraderPayload {
  user: User
}

type SendValidationEmailPayload {
  success: Boolean!
}

type CreateUserSubscriptionPayload {
  user: User!
}

type UpdateUserSubscriptionPayload {
  user: User!
}

type AuthenticatedUserSubscriptionPayload {
  user: User!
}

type UserReward {
  user: User!
  wager: Float!
  ggr: Float!
  pnl: Float!
  ar: Float!
  manualRewards: Float!
  supportRewards: Float!
  gratuityRewards: Float!
  sponsorshipRewards: Float!
  expired: Float!
  rakebackValue: Float!
  pnlWithRewards: Float!
  expected: Float!
  difference: Float!
}

type PlayerRevenue {
  currentBalance: Float
  depositCount: Int
  depositTotal: Float
  holdPercentage: Float
  issuedRevShare: Float
  withdrawAmount: Float
}

type CashPlayMetrics {
  baseEdgeExpectedGgr: Float
  difference: Float
  expected: Float
  expectedGgr: Float
  ggr: Float
  ggrWithRewards: Float
  wagered: Float
  wins: Float
}

type GameProfit {
  boxes: Float
  boxesPvp: Float
  crash: Float
  dice: Float
  liveGames: Float
  plinko: Float
  roulette: Float
  slots: Float
  upgrades: Float
}

type AffiliateRewards {
  attributedPlayers: Int
  revShare: Float
  revShareValue: Float
}

type BonusCurrency {
  awarded: Float
  balance: Float
  converted: Float
}

type ShortTermCash {
  claimed: Float
  totalAwarded: Float
  unclaimed: Float
}

type LifeTimeCash {
  claimable: Float
  claimed: Float
  dailyLimit: Float
  unclaimed: Float
}

type Alterations {
  gratuity: Float
  manual: Float
  sponsorship: Float
  support: Float
}

type UserStatistics {
  affiliateRewards: AffiliateRewards!
  allTimeStatistics: UserStatistics
  alterations: Alterations!
  bonusCurrency: BonusCurrency!
  cashPlayMetrics: CashPlayMetrics!
  gamesProfit: GameProfit!
  lifeTimeCash: LifeTimeCash!
  playerRevenue: PlayerRevenue!
  shortTermCash: ShortTermCash!
  user: User!
}

input DisableTotpTwoFactorAuthenticationInput {
  password: String
  token: String
  userId: ID
}

input EnableTotpTwoFactorAuthenticationInput {
  token: String!
}

input GenerateNewTotpTwoFactorBackupCodesInput {
  token: String!
}

input InvalidateAllUserSessionsInput {
  userId: ID
}

input UpdateUserInput {
  ancestorAffiliateTierId: ID
  authentic: Boolean
  bannedUntil: SequelizeDate
  banReason: String
  customTitle: String
  customTitleColor: String
  dailyWithdrawLimit: Float
  displayName: String
  forceBlankAvatar: Boolean
  hideSteamProfile: Boolean
  marketId: ID
  marketingEmails: Boolean
  microphoneEnabled: Boolean
  matchBettingBannedUntil: SequelizeDate
  matchBettingBanReason: String
  matchBettingMaximumTotalBetAmount: Float
  mutedUntil: SequelizeDate
  permissions: Int
  referralPromoCode: String
  roles: [UserRole]
  steamApiKey: String
  steamTradeUrl: String
  supplier: Boolean
  suspectedTrader: Boolean
  tags: [String]
  teamId: ID
  tradeBannedUntil: SequelizeDate
  tradeBanReason: String
  trader: Boolean
  userId: ID!
  verificationStatus: VerificationStatus
  rank: Int
}

input UpdateUserEmailInput {
  email: String!
  redirectUri: String!
  twoFactorToken: String
  userId: ID!
}

input RetrieveTotpTwoFactorBackupCodesInput {
  token: String!
}

input RevertUserInput {
  userId: ID!
  dateTime: SequelizeDate!
}

input AcceptTosInput {
  acceptTos: Boolean
  version: Int
}

input UpdateSuspectedTraderInput {
  userId: ID!
}

input SendValidationEmailInput {
  redirectUri: String!
  userId: ID!
}

enum UserOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  XP
  XP_DESC
  BALANCE
  BALANCE_DESC
  TOTAL_DEPOSIT
  TOTAL_DEPOSIT_DESC
  LAST_DEPOSIT_AT
  LAST_DEPOSIT_AT_DESC
  TOTAL_WITHDRAW
  TOTAL_WITHDRAW_DESC
  BOX_OPENINGS
  BOX_OPENINGS_DESC
  TICKETS
  TICKETS_DESC
  TOTAL_COMMISSION_EARNT
  TOTAL_COMMISSION_EARNT_DESC
  INVENTORY_VALUE
  INVENTORY_VALUE_DESC
}

enum UserPermission {
  USER
  MODERATOR
  SUPPORT
  ADMIN
}

enum UserRole {
  ASSET_ADMIN
  ASSET_VIEWER
  AFFILIATE_ADMIN
  AFFILIATE_VIEWER
  ALTER_BALANCE
  ALTER_BALANCE_NO_LIMIT
  AUDIT_LOG_VIEWER
  BOX_ADMIN
  BOX_CREATOR
  BOX_EDITOR
  BOX_OPENING_VIEWER
  BOX_VIEWER
  CASINO_GAME_ADMIN
  DASHBOARD_VIEWER
  DEBUGGER
  DEVELOPER
  DIGITAL_CODE_VIEWER
  EXCHANGE_VIEWER
  GEO_TRACK_VIEWER
  ITEM_ADMIN
  ITEM_VIEWER
  JACKPOT_ADMIN
  JACKPOT_PAYER
  MANAGER
  MATCH_BETTING_ADMIN
  MATCH_BETTING_DASHBOARD_VIEWER
  MATCH_BETTING_FRAUD
  MATCH_BETTING_PROCESSOR
  MATCH_BETTING_USER
  MODERATOR
  ORDER_ADMIN
  ORDER_VIEWER
  OWNER
  PAYMENT_ADMIN
  POLL_ADMIN
  POLL_VIEWER
  PROMO_CODE_VIEWER
  PVP_BOT_VIEWER
  RISK_FRAUD
  STAFF
  STEAM_OFFER_VIEWER
  SUPPORT
  SUPPORT_PLUS
  TILE_OPENING_VIEWER
  TILE_SETTING_ADMIN
  TRADE_VIEWER
  TRANSACTION_VIEWER
  USER
  USER_ITEM_VIEWER
  USER_PROMO_CODE_VIEWER
  USER_VIEWER
  USER_TIER_ADMIN
  USER_TWO_FACTOR_ADMIN
  WALLET_CHANGE_SUMMARY_VIEWER
  WALLET_CHANGE_VIEWER
  WALLET_VIEWER
  WAXPEER_TRADE_VIEWER
  WITHDRAWAL_REQUEST_VIEWER
  ZINC_ORDER_VIEWER
  PROMOTION_ADMIN
}

enum VerificationStatus {
  UNDER_LIMIT
  REQUIRED
  VERIFIED
}

enum UserWithdrawalRestrictions {
  NO_RESTRICTIONS
  PENDING
  RESTRICTED
}

enum UserTradeBannedType {
  INTERNAL
  STEAM
}

type VerifyEmailPayload {
  user: User
}

input VerifyEmailInput {
  hash: String!
  recaptcha: String!
  visualRecaptcha: String
}

input ResendVerificationEmailInput {
  userId: String!
  recaptcha: String!
  visualRecaptcha: String
}

type WalletChange implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  currency: String!
  externalId: ID
  externalItem: SourceModels!
  notes: [Note!]
  type: WalletChangeType!
  user: User
  userId: ID
  valueAfter: Decimal!
  valueChange: Decimal!
  wallet: Wallet
  walletId: ID
}

type WalletChangeConnection {
  pageInfo: PageInfo!
  edges: [WalletChangeEdge]
  total: Int
}

type WalletChangeEdge {
  node: WalletChange
  cursor: String!
  index: Int
}

type WalletChangesSummaryConnection {
  pageInfo: PageInfo!
  edges: [WalletChangesSummaryEdge]
  total: Int
}

type WalletChangesSummaryEdge {
  node: WalletChangesSummary
  cursor: String!
}

type WalletChangesSummary {
  currency: String!
  deposits: Float!
  exchanges: Float!
  games: Float!
  misc: Float!
  userId: ID!
  withdraws: Float!
}

type GenerateWalletChangesCsvPayload {
  fileName: String!
}

input GenerateWalletChangesCsvInput {
  after: String
  first: PaginationAmount
  before: String
  last: PaginationAmount
  orderBy: [WalletChangeOrderBy]
  createdAtMaxDate: SequelizeDate
  createdAtMinDate: SequelizeDate
  type: [WalletChangeType!]
  userId: ID
  walletIds: [ID!]
}

enum WalletChangeOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum WalletChangeType {
  ACHIEVEMENT_CLAIM
  AFFILIATE_LOAN
  ALTERATION
  BOX_OPEN
  BOX_PURCHASE
  BOX_REFUND
  BOX_WIN
  CASINO_GAME_BET
  CASINO_GAME_ROLLBACK
  CASINO_GAME_WIN
  COMMISSION
  COMMISSION_CLAIMED
  COMPENSATION
  COMPENSATION_STREAMER
  CRASH_BET
  CRASH_REFUND
  CRASH_WIN
  CURRENCY_CONVERSION
  DICE_BET
  DICE_JACKPOT
  DICE_UPGRADE_BET
  DICE_UPGRADE_WIN
  DICE_WIN
  GAME_BET
  GAME_JACKPOT
  GAME_WIN
  GEMSTONE_GAME_WIN
  GIFT_CARD
  GIVEAWAY_WIN
  ITEM_EXCHANGE
  ITEM_WITHDRAW
  JACKPOT_PAYOUT
  MATCH_BETTING_SLIP_BET
  MATCH_BETTING_SLIP_ROLLBACK
  MATCH_BETTING_SLIP_WIN
  PAYMENT
  PAYMENT_BONUS
  PAYMENT_WITHDRAWAL
  PLINKO_BET
  PLINKO_WIN
  PROMO_CODE
  PVP_BET
  PVP_BET_REFUND
  PVP_BOT_TOP_UP
  PVP_BOX_GAME_BET
  PVP_WIN
  RAKEBACK
  RAKEBACK_ASSET
  RAKEBACK_CLAIMED
  RANK_UP_GAME_BET
  TILE_OPENING
  TRADE_DEPOSIT
  TRADE_JOIN
  TRANSFER
  USER_IMPORT
  USER_ITEM_EXCHANGE_REVERT
  WALLET_MOVE
  WAX_PEER_TRADE
  XP_PURCHASE
  ZBT_TRADE
  ADDITIONAL_REWARDS_DAILY
  ADDITIONAL_REWARDS_WEEKLY
  ADDITIONAL_REWARDS_MONTHLY
  ADDITIONAL_REWARDS_DAILY_CLAIMED
  ADDITIONAL_REWARDS_WEEKLY_CLAIMED
  ADDITIONAL_REWARDS_MONTHLY_CLAIMED
  SUPPORT
  SPONSORSHIP
  MANUAL_REWARD
  GRATUITY
}

enum WalletChangesSummaryOrderBy {
  DEPOSITS
  DEPOSITS_DESC
  EXCHANGES
  EXCHANGES_DESC
  GAMES
  GAMES_DESC
  MISC
  MISC_DESC
  WITHDRAWS
  WITHDRAWS_DESC
}

type Wallet implements Node {
  id: ID!
  name: WalletType
  amount: Float
  currency: String!
  userId: ID
  user: User
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  expiresAt: SequelizeDate
  claimableFrom: SequelizeDate
  changes(after: String, first: PaginationAmount, before: String, last: PaginationAmount, orderBy: [WalletChangeOrderBy]): WalletChangeConnection
}

type WalletConnection {
  pageInfo: PageInfo!
  edges: [WalletEdge]
  total: Int
}

type WalletEdge {
  node: Wallet
  cursor: String!
}

type UpdateWalletPayload {
  note: Note
  type: WalletChangeType @deprecated(reason: "Not used")
  wallet: Wallet @deprecated(reason: "Use wallets instead")
  wallets: [Wallet!]
}

type ConsolidateWalletsPayload {
  wallets: [Wallet!]
}

type MoveBetweenWalletsPayload {
  errorCount: Int!
  walletIds: [ID!]!
}

type UpdateWalletSubscriptionPayload {
  wallet: Wallet!
  walletChange: WalletChange!
}

type AdditionalRewardClaimPayload {
  walletType: WalletType!
  claimedAmount: Float!
  claimedAt: SequelizeDate!
}

type RakebackClaimPayload {
  rakebackSpent: Float!
  rakebackValueGenerated: Float!
}

input UpdateWalletInput {
  walletId: ID!
  note: String!
  diff: Float!
  type: WalletChangeType
}

input AffiliateClaimAmountInput {
  amount: Float!
}

input ConsolidateWalletsInput {
  fromCurrency: String
  toCurrency: String
  toWalletType: WalletType
  userId: ID
  walletId: ID
  walletType: WalletType
}

input MoveBetweenWalletsInput {
  toCurrency: String
  toWalletType: WalletType!
  fromWalletType: WalletType!
}

input AdditionalRewardClaimInput {
  walletType: WalletType!
}

input RakebackClaimInput {
  amount: Float!
}

enum WalletOrderBy {
  ID
  ID_DESC
  AMOUNT
  AMOUNT_DESC
}

enum WalletType {
  ADDITIONAL_REWARDS_DAILY
  ADDITIONAL_REWARDS_MONTHLY
  ADDITIONAL_REWARDS_WEEKLY
  AFFILIATE_EARNINGS
  BONUS
  GEMSTONE
  GEMSTONE_SHINY
  MAIN
  RAKEBACK
}

type WaxPeerTrade implements Node {
  id: ID!
  itemVariantId: ID!
  itemVariant: ItemVariant
  userId: ID!
  user: User
  value: Float!
  valuePaid: Float
  currency: String!
  status: WaxPeerTradeStatus!
  partner: String
  token: String
  externalId: String
  externalStatus: WaxPeerTradeExternalStatus
  tradeOfferId: String
  externalMessage: String
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  expiresAt: SequelizeDate
  externalItemId: String
  float: String
  iconUrl: String
  isOfferSent: Boolean!
}

type WaxPeerTradeConnection {
  pageInfo: PageInfo!
  edges: [WaxPeerTradeEdge]
  total: Int
}

type WaxPeerTradeEdge {
  node: WaxPeerTrade
  cursor: String!
}

type WaxPeerItemConnection {
  pageInfo: PageInfo!
  edges: [WaxPeerItemEdge]
  total: Int
}

type WaxPeerItemEdge {
  node: WaxPeerItem
  cursor: String!
}

type CreateWaxPeerTradePayload {
  waxPeerTrade: WaxPeerTrade!
}

type TrackWaxPeerTradePayload {
  success: Boolean!
}

type CreateWaxPeerTradeSubscriptionPayload {
  waxPeerTrade: WaxPeerTrade!
}

type UpdateWaxPeerTradeSubscriptionPayload {
  waxPeerTrade: WaxPeerTrade!
}

type WaxPeerItem {
  float: String
  iconUrl: String
  id: ID!
  itemVariant: ItemVariant!
  value: Float!
}

input CreateWaxPeerTradeInput {
  itemVariantId: ID!
  recaptcha: String!
  value: Float!
  float: String
  iconUrl: String
  visualRecaptcha: String
  waxPeerItemId: ID
}

input TrackWaxPeerTradeInput {
  waxPeerTradeId: ID!
  secret: String
}

enum WaxPeerTradeOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  VALUE
  VALUE_DESC
  UPDATED_AT
  UPDATED_AT_DESC
}

enum WaxPeerItemOrderBy {
  BEST_DEALS_ASC
  BEST_DEALS_DESC
  PRICE_ASC
  PRICE_DESC
}

enum WaxPeerTradeStatus {
  COMPLETED
  CREATED
  FAILED
  PROCESSING
}

enum WaxPeerTradeExternalStatus {
  COMPLETED
  DECLINED_AND_REFUNDED
  EXCEPTION
  PROCESSING
  SENT
  WAITING
  WAITING_FOR_SELLER_CONFIRMATION
}

type Wishlist implements Node {
  id: ID!
  userId: ID!
  user: User!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  itemVariants: [WishlistItemVariant!]!
  totalValue: Float!
  currency: String!
  totalValueBase: Float!
  baseCurrency: String!
  jackpotId: ID
}

type WishlistConnection {
  pageInfo: PageInfo!
  edges: [WishlistEdge]
  total: Int
}

type WishlistEdge {
  node: Wishlist
  cursor: String!
}

type CreateWishlistPayload {
  wishlist: Wishlist
}

type UpdateWishlistPayload {
  wishlist: Wishlist
}

type WishlistItemVariant {
  itemVariantId: ID!
  itemVariant: ItemVariant!
  value: Float!
}

input CreateWishlistInput {
  itemVariantIds: [ID!]!
  jackpotId: ID
}

input UpdateWishlistInput {
  itemVariantIds: [ID!]!
  wishlistId: ID!
}

enum WishlistOrderBy {
  ID
  ID_DESC
}

type WithdrawalRequest implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  userId: ID!
  user: User
  processorId: ID
  processor: User
  amount: Float!
  approvedHistory: CreateWithdrawalHistory
  currency: String!
  status: WithdrawalRequestStatus!
}

type WithdrawalRequestConnection {
  pageInfo: PageInfo!
  edges: [WithdrawalRequestEdge]
  total: Int
}

type WithdrawalRequestEdge {
  node: WithdrawalRequest
  cursor: String!
}

type CreateWithdrawalRequestPayload {
  withdrawalRequest: WithdrawalRequest!
}

type UpdateWithdrawalRequestPayload {
  withdrawalRequest: WithdrawalRequest!
}

type IncreaseWithdrawalRequestPayload {
  withdrawalRequest: WithdrawalRequest!
}

type CreateWithdrawalRequestSubscriptionPayload {
  withdrawalRequest: WithdrawalRequest!
}

type UpdateWithdrawalRequestSubscriptionPayload {
  withdrawalRequest: WithdrawalRequest!
}

type CreateWithdrawalHistory {
  count: Int
  sum: Float
}

input CreateWithdrawalRequestInput {
  amount: Float!
}

input UpdateWithdrawalRequestInput {
  withdrawalRequestId: ID!
  amount: Float!
  status: WithdrawalRequestStatus!
}

input IncreaseWithdrawalRequestInput {
  amount: Float!
  globalId: String!
}

enum WithdrawalRequestOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum WithdrawalRequestStatus {
  APPROVED
  DENIED
  PENDING
}

type ZbtTrade implements Node {
  id: ID!
  itemVariantId: ID!
  itemVariant: ItemVariant
  userId: ID!
  user: User
  value: Float!
  valuePaid: Float
  currency: String!
  status: ZbtTradeStatus!
  steamAppName: SteamAppName!
  steamTradeUrl: String!
  isOfferSent: Boolean!
  externalId: String
  externalStatus: ZbtTradeExternalStatus
  externalItemId: String
  externalMessage: String
  float: String
  iconUrl: String
  tradeOfferId: String
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type ZbtTradeConnection {
  pageInfo: PageInfo!
  edges: [ZbtTradeEdge]
  total: Int
}

type ZbtTradeEdge {
  node: ZbtTrade
  cursor: String!
}

type ZbtMarketplaceItemConnection {
  pageInfo: PageInfo!
  edges: [ZbtMarketplaceItemEdge]
  total: Int
}

type ZbtMarketplaceItemEdge {
  node: ZbtMarketplaceItem
  cursor: String!
}

type ZbtMarketplaceItem {
  float: String
  iconUrl: String
  id: ID!
  itemVariant: ItemVariant!
  quantity: Int!
  value: Float!
}

type CancelZbtTradePayload {
  success: Boolean!
}

type CreateZbtTradePayload {
  zbtTrade: ZbtTrade!
}

type TrackZbtTradePayload {
  success: Boolean!
}

type CreateZbtTradeSubscriptionPayload {
  zbtTrade: ZbtTrade!
}

type UpdateZbtTradeSubscriptionPayload {
  zbtTrade: ZbtTrade!
}

input CancelZbtTradeInput {
  zbtTradeId: ID!
}

input CreateZbtTradeInput {
  itemVariantId: ID!
  recaptcha: String!
  steamAppName: SteamAppName!
  value: Float!
  float: String
  iconUrl: String
  visualRecaptcha: String
}

input TrackZbtTradeInput {
  zbtTradeId: ID!
  secret: String
}

enum ZbtTradeOrderBy {
  ID
  ID_DESC
  VALUE
  VALUE_DESC
}

enum ZbtMarketplaceItemOrderBy {
  PRICE_ASC
  PRICE_DESC
}

enum ZbtTradeStatus {
  COMPLETED
  CREATED
  FAILED
  PROCESSING
}

enum ZbtTradeExternalStatus {
  CANCELLED
  COMPLETED
  RECEIVING
  WAITING_FOR_DELIVERY
  WAITING_FOR_PAYMENT
  WAITING_FOR_RECEIPT
}

type ZincOrder implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  requestId: String!
  merchantOrders: [ZincMerchantOrder!]!
  status: ZincOrderStatus!
  creatorId: ID!
  creator: User
  orderId: ID!
  order: Order!
  retailer: String @deprecated(reason: "Use retailerId")
  retailerId: ID!
  retailerObject: RetailerType
  giftMessage: String!
  maxOrderCost: Float!
  maxShippingCost: Float!
  maxShippingDays: Float!
  shippingPriority: ShippingPriority!
  primeOptout: Boolean
  priorityBid: Int
}

type ZincOrderConnection {
  pageInfo: PageInfo!
  edges: [ZincOrderEdge]
  total: Int
}

type ZincOrderEdge {
  node: ZincOrder
  cursor: String!
}

type CreateZincOrderPayload {
  zincOrder: ZincOrder
}

type AbortZincOrderPayload {
  zincOrder: ZincOrder
}

type CancelZincOrderPayload {
  zincOrder: ZincOrder
}

type RetryZincOrderPayload {
  zincOrder: ZincOrder
}

type CreateZincOrderSubscriptionPayload {
  zincOrder: ZincOrder!
}

type UpdateZincOrderSubscriptionPayload {
  zincOrder: ZincOrder!
}

type DeleteZincOrderSubscriptionPayload {
  zincOrder: ZincOrder!
}

type ZincMerchantOrder {
  merchantOrderId: String
  merchant: String
  account: String
  placedAt: SequelizeDate
  tracking: [String]
  productIds: [String]
  trackingUrl: String
  deliveryDate: String
  cancelledAt: SequelizeDate
}

type ZincProductSearchItem {
  productId: String
  title: String
  image: String
  reviewCount: Int
  rating: Float
  fresh: Boolean
  price: Float
}

type ZincProductSearchPayload {
  products: [ZincProductSearchItem!]!
}

input CreateZincOrderInput {
  giftMessage: String!
  maxOrderCost: Float!
  maxShippingCost: Float!
  maxShippingDays: Float!
  shippingPriority: ShippingPriority!
  userItemIds: [ID!]!
  discount: Int
  primeOptout: Boolean
  priorityBid: Int
}

input AbortZincOrderInput {
  zincOrderId: ID!
}

input CancelZincOrderInput {
  zincOrderId: ID!
}

input RetryZincOrderInput {
  zincOrderId: ID!
}

input ZincProductSearchInput {
  query: String!
  retailer: Retailer @deprecated(reason: "Use retailerId")
  retailerId: ID
  page: Int!
}

enum ZincOrderOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum ZincOrderStatus {
  ABORTED
  ABORTING
  CANCELLED
  CANCELLING
  CREATED
  FAILED
  ORDERED
  ORDERING
}

enum Retailer {
  ALIEXPRESS
  AMAZON_CA
  AMAZON_DE
  AMAZON_MX
  AMAZON_UK
  AMAZON_US
  CLOUTJUICE_MERCH
  COSTCO
  FARFETCH
  HOMEDEPOT
  LOWES
  REDBUBBLE
  STOCKX
  WALMART
}

enum ProductCondition {
  NEW
  REFURBISHED
  UNACCEPTABLE
  USED_ACCEPTABLE
  USED_GOOD
  USED_LIKE_NEW
  USED_VERY_GOOD
}

enum ShippingPriority {
  CHEAPEST
  FASTEST
}
